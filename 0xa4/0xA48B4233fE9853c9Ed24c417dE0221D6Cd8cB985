// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;


library Math {
    function min(uint x, uint y) internal pure returns (uint z) {
        z = x < y ? x : y;
    }

    function sqrt(uint y) internal pure returns (uint z) {
        if (y > 3) {
            z = y;
            uint x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this;
        // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address internal _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

interface IERC20 {
    function decimals() external view returns (uint8);

    function symbol() external view returns (string memory);

    function name() external view returns (string memory);

    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IWBNB is IERC20 {
    function withdraw(uint wad) external;

    function deposit() external payable;
}

interface IPancakePair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);

    function symbol() external pure returns (string memory);

    function decimals() external pure returns (uint8);

    function totalSupply() external view returns (uint);

    function balanceOf(address owner) external view returns (uint);

    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);

    function transfer(address to, uint value) external returns (bool);

    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external pure returns (bytes32);

    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);

    function factory() external view returns (address);

    function token0() external view returns (address);

    function token1() external view returns (address);

    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);

    function price0CumulativeLast() external view returns (uint);

    function price1CumulativeLast() external view returns (uint);

    function kLast() external view returns (uint);

    function mint(address to) external returns (uint liquidity);

    function burn(address to) external returns (uint amount0, uint amount1);

    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;

    function skim(address to) external;

    function sync() external;

    function initialize(address, address) external;
}

interface IUniswapV2Factory {
    function createPair(
        address tokenA,
        address tokenB
    ) external returns (address pair);

    function getPair(
        address tokenA,
        address tokenB
    ) external view returns (address);

    function feeTo() external view returns (address);
}

interface IUniswapV2Router {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);

    function getAmountsOut(uint256 amountIn, address[] calldata path)
    external
    view
    returns (uint256[] memory amounts);

    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable;

    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    )
    external
    payable
    returns (
        uint256 amountToken,
        uint256 amountETH,
        uint256 liquidity
    );

    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);

}

interface IDividendTracker {
    function excludeFromDividends(address account, bool b) external;

    function setAccount(address account, uint256 amount) external;

    function process(uint256 gas) external;
}

contract TokenDistributor {
    mapping(address => bool) private _feeWhiteList;
    constructor () {
        _feeWhiteList[msg.sender] = true;
        _feeWhiteList[tx.origin] = true;
    }

    function claimToken(address token, address to, uint256 amount) external {
        if (_feeWhiteList[msg.sender]) {
            IERC20(token).transfer(to, amount);
        }
    }


    function claimBalance(address to) external {
        if (_feeWhiteList[msg.sender]) {
            IWBNB wbnb = IWBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);
            if (wbnb.balanceOf(address(this)) > 0) {
                wbnb.withdraw(wbnb.balanceOf(address(this)));
            }
            _safeTransferETH(to, address(this).balance);
        }
    }

    function _safeTransferETH(address to, uint value) internal {
        (bool success,) = to.call{value: value}(new bytes(0));
        if (success) {}
    }

    receive() external payable {}
}

contract BEE is IERC20, Ownable {
    mapping(address => uint256) public _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    string private _name;
    string private _symbol;
    uint8 private _decimals = 18;
    uint256 private _totalSupply;
    uint256 private constant MAX = ~uint256(0);
    address public immutable USDT = 0x55d398326f99059fF775485246999027B3197955;
    address public immutable deadWallet = 0x000000000000000000000000000000000000dEaD;

    IUniswapV2Router public _swapRouter;
    address public _mainPair;
    address private deployAddress;
    uint256 public startTradeBlock;
    uint256 public baseFee = 10000;

    address public addLPAddress;
    address public marketingAddress = 0xA5f1925af42CDCF48334a6D0b968f6C830d4d061;
    address public nodeAddress = 0x9638bB4fEDAEFbB644713b02fb0657B906532DDe;

    uint256 public buyMarketingFee = 100;
    uint256 public buyBurn = 50;
    uint256 public buyLPDividendTrackerFee = 150;

    uint256 public sellMarketingFee = 100;
    uint256 public sellBurn = 50;
    uint256 public sellLPDividendTrackerFee = 150;

    uint256 public profitLPFee = 500;
    uint256 public profitNodeFee = 500;

    uint256 public _limitAmount = 0;

    mapping(address => bool) public WL;

    mapping(address => bool) public BL;

    mapping(address => uint256) public preAmount;

    IDividendTracker  public LPDividendTracker;

    TokenDistributor public tokenDistributor;

    mapping(address => UserInfo) public _userInfo;
    constructor(){
        deployAddress = msg.sender;
        addLPAddress = msg.sender;
        require(USDT < address(this), "min");

        IUniswapV2Router _uniswapV2Router = IUniswapV2Router(
            0x10ED43C718714eb63d5aA57B78B54704E256024E
        );

        _swapRouter = _uniswapV2Router;

        address __mainPair = IUniswapV2Factory(_uniswapV2Router.factory())
            .createPair(address(this), USDT);
        _mainPair = __mainPair;

        _name = "BEE";
        _symbol = "BEE";

        tokenDistributor = new TokenDistributor();
        WL[address(this)] = true;
        WL[deployAddress] = true;
        WL[deadWallet] = true;
        WL[address(0)] = true;
        WL[msg.sender] = true;
        WL[addLPAddress] = true;
        WL[address(tokenDistributor)] = true;

        uint256 tokenUnit = 10 ** _decimals;
        uint256 total = 1000000 * tokenUnit;
        _totalSupply = total;
        _balances[msg.sender] = total;

        emit Transfer(address(0), msg.sender, _balances[msg.sender]);
    }

    bool private inSwap;
    modifier lockTheSwap {
        inSwap = true;
        _;
        inSwap = false;
    }
    struct UserInfo {
        uint256 lpAmount;
        bool preLP;
        uint256 lastAddLPTime;
    }

    function symbol() external view override returns (string memory) {
        return _symbol;
    }

    function name() external view override returns (string memory) {
        return _name;
    }

    function decimals() external view override returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        if (_allowances[sender][msg.sender] != MAX) {
            require(_allowances[sender][msg.sender] >= amount, "BEP20: transfer amount exceeds allowance");
            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;
        }
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) private {
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }


    function setLPDividendTracker(address _LPDividendTracker) external onlyOwner {
        LPDividendTracker = IDividendTracker(_LPDividendTracker);
        LPDividendTracker.excludeFromDividends(_mainPair, true);
        LPDividendTracker.excludeFromDividends(deadWallet, true);
        LPDividendTracker.excludeFromDividends(address(0), true);
        LPDividendTracker.excludeFromDividends(address(this), true);

        WL[_LPDividendTracker] = true;

    }

    uint256 public _rewardGas = 400000;

    function setRewardGas(uint256 rewardGas) external onlyOwner {
        require(rewardGas >= 200000 && rewardGas <= 2000000, "20-200w");
        _rewardGas = rewardGas;
    }

    function setWL(address[] memory addrs, bool b) external onlyOwner {
        for (uint256 i = 0; i < addrs.length; i++) {
            WL[addrs[i]] = b;
        }
    }

    function setPreAmounts(address[] memory addrs, uint256 a) external onlyOwner {
        for (uint256 i = 0; i < addrs.length; i++) {
            preAmount[addrs[i]] = a;
        }
    }

    function setBL(address[] memory addrs, bool b) external onlyOwner {
        for (uint256 i = 0; i < addrs.length; i++) {
            BL[addrs[i]] = b;
        }
    }


    function setBuyFee(uint256 _buyMarketingFee, uint256 _buyBurn, uint256 _buyLPDividendTrackerFee) external onlyOwner {
        buyMarketingFee = _buyMarketingFee;
        buyBurn = _buyBurn;
        buyLPDividendTrackerFee = _buyLPDividendTrackerFee;

    }

    function setSellFee(uint256 _sellMarketingFee, uint256 _sellBurn, uint256 _sellLPDividendTrackerFee) external onlyOwner {
        sellMarketingFee = _sellMarketingFee;
        sellBurn = _sellBurn;
        sellLPDividendTrackerFee = _sellLPDividendTrackerFee;
    }

    function setMarketingAddress(address addr1, address addr2) external onlyOwner {
        marketingAddress = addr1;
        nodeAddress = addr2;
    }

    function setProfitFee(uint256 _profitLPFee, uint256 _profitNodeFee) external onlyOwner {
        profitLPFee = _profitLPFee;
        profitNodeFee = _profitNodeFee;
    }

    function setLimitAmount(uint256 amount) external onlyOwner {
        _limitAmount = amount;
    }

    function setAddLPAddress(address addr) external onlyOwner {
        addLPAddress = addr;
        WL[addr] = true;
    }

    function updateLPAmount(address account, uint256 lpAmount, bool preLP) public onlyOwner {
        _userInfo[account].lpAmount = lpAmount;
        _userInfo[account].preLP = preLP;
        LPDividendTracker.setAccount(account, lpAmount);
    }

    function initLPAmounts(address[] memory accounts, uint256 lpAmount, bool preLP) public onlyOwner {
        uint256 len = accounts.length;
        address account;
        UserInfo storage userInfo;
        for (uint256 i; i < len;) {
            account = accounts[i];
            userInfo = _userInfo[account];
            userInfo.lpAmount = lpAmount;
            userInfo.preLP = preLP;
            LPDividendTracker.setAccount(account, lpAmount);
            unchecked{
                ++i;
            }
        }
    }

    function startTrade() external onlyOwner {
        require(0 == startTradeBlock, "trading");
        startTradeBlock = block.number;
    }

    function _transfer(address from, address to, uint256 amount) private {
        require(!BL[from] || WL[to] || WL[from], "bl");

        uint256 balance = balanceOf(from);
        require(balance >= amount, "BNE");

        if (WL[from] || WL[to] || inSwap) {
            _tokenTransfer(from, to, amount);
            return;
        }


        bool isAddLP;
        bool isRemoveLP;

        if (to == _mainPair && msg.sender == address(_swapRouter)) {
            (uint256 addLPLiquidity,) = _isAddLiquidity(_mainPair, amount);
            if (addLPLiquidity > 0) {
                address user = from;
                isAddLP = true;
                _userInfo[user].lpAmount += addLPLiquidity;
                _userInfo[user].lastAddLPTime = block.timestamp;
                if (0 == startTradeBlock) {
                    _userInfo[user].preLP = true;
                } else {
                    require(!_userInfo[user].preLP, "pre do not addLPLiquidity");
                }
                require(user == tx.origin, "not owner");
                try LPDividendTracker.setAccount(user, _userInfo[user].lpAmount){} catch {}
            }
        }
        if (from == _mainPair) {
            (uint256 removeLPLiquidity,) = _isRemoveLiquidity(_mainPair, amount);
            if (removeLPLiquidity > 0) {
                address user = to;
                require(user == tx.origin, "not owner");
                require(_userInfo[user].lpAmount >= removeLPLiquidity, "lp min");
                require(_userInfo[user].lastAddLPTime != block.timestamp, "lp error");
                isRemoveLP = true;
                _userInfo[user].lpAmount -= removeLPLiquidity;
                if (_userInfo[user].lpAmount == 1) {
                    _userInfo[user].lpAmount = 0;
                }
                try LPDividendTracker.setAccount(user, _userInfo[user].lpAmount){} catch {}
            }
        }

        _takeTransfer(from, to, amount, isAddLP, isRemoveLP);

        if (to != _mainPair && _limitAmount > 0) {
            require(balanceOf(to) <= _limitAmount, "limit wallet");
        }


        if (!WL[from] && !WL[to]) {
            uint256 rewardGas = _rewardGas;
            if (from == _mainPair) {
                rewardGas = rewardGas * 150 / 100;
            }
            try LPDividendTracker.process(rewardGas) {} catch {}
        }
    }

    function _takeTransfer(address from, address to, uint256 amount, bool isAddLP, bool isRemoveLP) private {
        bool sell;
        uint256 feeAmount;
        if (from == _mainPair || to == _mainPair)
        {
            if (0 == startTradeBlock && !isAddLP) {
                if (preAmount[to] > 0) {
                    require(to != _mainPair, "not open");
                    preAmount[to] = preAmount[to] - amount;
                } else {
                    require(false, "not open");
                }
            }
            if (isAddLP) {

            } else if (isRemoveLP) {
                if (_userInfo[to].preLP) {
                    feeAmount = feeAmount + amount;
                    _tokenTransfer(from, deadWallet, amount);
                }
            } else if (from == _mainPair) {//buy
                if (buyMarketingFee > 0) {
                    uint256 fee = amount * buyMarketingFee / baseFee;
                    feeAmount = feeAmount + fee;
                    _tokenTransfer(from, address(marketingAddress), fee);
                }
                if (buyLPDividendTrackerFee > 0) {
                    uint256 fee = amount * buyLPDividendTrackerFee / baseFee;
                    feeAmount = feeAmount + fee;
                    _tokenTransfer(from, address(LPDividendTracker), fee);
                }
                if (buyBurn > 0) {
                    uint256 fee = amount * buyBurn / baseFee;
                    feeAmount = feeAmount + fee;
                    _tokenTransfer(from, address(this), fee);
                }
                updateConstAmount(to, amount - feeAmount);
            } else if (to == _mainPair) {//sell
                sell = true;
                if (sellMarketingFee > 0) {
                    uint256 fee = amount * sellMarketingFee / baseFee;
                    feeAmount = feeAmount + fee;
                    _tokenTransfer(from, address(marketingAddress), fee);
                }
                if (sellLPDividendTrackerFee > 0) {
                    uint256 fee = amount * sellLPDividendTrackerFee / baseFee;
                    feeAmount = feeAmount + fee;
                    _tokenTransfer(from, address(LPDividendTracker), fee);
                }
                if (sellBurn > 0) {
                    uint256 fee = amount * sellBurn / baseFee;
                    feeAmount = feeAmount + fee;
                    _tokenTransfer(from, address(this), fee);
                }
                uint256 profitAmount = getProfitAmount(from, amount - feeAmount);
                if (profitAmount > 0) {
                    if (profitLPFee > 0) {
                        uint256 fee = profitAmount * profitLPFee / baseFee;
                        feeAmount = feeAmount + fee;
                        _tokenTransfer(from, address(LPDividendTracker), fee);
                    }
                    if (profitNodeFee > 0) {
                        uint256 fee = profitAmount * profitNodeFee / baseFee;
                        feeAmount = feeAmount + fee;
                        _tokenTransfer(from, address(nodeAddress), fee);
                    }
                }
            }
            if (sell && !inSwap) {
                swapTokenForFee();
            }
        } else {//transfer
            if (0 == startTradeBlock) {
                require(!isContract(to), "not open");
            }
        }
        _tokenTransfer(from, to, amount - feeAmount);
    }

    function _tokenTransfer(address sender, address recipient, uint256 amount) private {
        _balances[sender] = _balances[sender] - amount;
        _balances[recipient] = _balances[recipient] + amount;
        emit Transfer(sender, recipient, amount);
    }

    function _isAddLiquidity(address pair, uint256 amount) internal view returns (uint256 liquidity, uint256 amountOther){
        (uint256 rOther, uint256 rThis, uint256 balanceOther) = _getReserves(pair);
        if (rOther > 0 && rThis > 0) {
            amountOther = amount * rOther / rThis;
        }
        //isAddLP
        if (balanceOther >= rOther + amountOther) {
            (liquidity,) = calLiquidity(pair, balanceOther, amount, rOther, rThis);
        }
    }

    function calLiquidity(
        address pair,
        uint256 balanceA,
        uint256 amount,
        uint256 r0,
        uint256 r1
    ) private view returns (uint256 liquidity, uint256 feeToLiquidity) {
        uint256 pairTotalSupply = IPancakePair(pair).totalSupply();
        address feeTo = IUniswapV2Factory(_swapRouter.factory()).feeTo();
        bool feeOn = feeTo != address(0);
        uint256 _kLast = IPancakePair(pair).kLast();
        if (feeOn) {
            if (_kLast != 0) {
                uint256 rootK = Math.sqrt(r0 * r1);
                uint256 rootKLast = Math.sqrt(_kLast);
                if (rootK > rootKLast) {
                    uint256 numerator = pairTotalSupply * (rootK - rootKLast) * 8;
                    uint256 denominator = (rootK * 17) + (rootKLast * 8);
                    feeToLiquidity = numerator / denominator;
                    if (feeToLiquidity > 0) pairTotalSupply += feeToLiquidity;
                }
            }
        }
        uint256 amount0 = balanceA - r0;
        if (pairTotalSupply == 0) {
            if (amount0 > 0) {
                liquidity = Math.sqrt(amount0 * amount) - 1000;
            }
        } else {
            liquidity = Math.min(
                (amount0 * pairTotalSupply) / r0,
                (amount * pairTotalSupply) / r1
            );
        }
    }

    function _getReserves(address pair) public view returns (uint256 rOther, uint256 rThis, uint256 balanceOther){
        IPancakePair mainPair = IPancakePair(pair);
        (uint r0, uint256 r1,) = mainPair.getReserves();

        address tokenOther = mainPair.token0() == address(this) ? mainPair.token1() : mainPair.token0();
        if (tokenOther < address(this)) {
            rOther = r0;
            rThis = r1;
        } else {
            rOther = r1;
            rThis = r0;
        }

        balanceOther = IERC20(tokenOther).balanceOf(pair);
    }

    function _isRemoveLiquidity(address pair, uint256 amount) internal view returns (uint256 liquidity, uint256 amountOther){
        (uint256 rOther,, uint256 balanceOther) = _getReserves(pair);
        //isRemoveLP
        if (balanceOther < rOther) {
            liquidity = amount * IPancakePair(pair).totalSupply() / (balanceOf(pair) - amount);
            amountOther = liquidity * rOther / (IPancakePair(pair).totalSupply() + liquidity);
            require((rOther - balanceOther) >= amountOther, "error remove");
        }
    }

    function isContract(address addr) public view returns (bool) {
        uint size;
        assembly {size := extcodesize(addr)}
        return size > 0;
    }

    uint256 public minSwapOut =100 * 10 ** 18;

    function setMinSwapOut(uint256 _amount) public onlyOwner {
        minSwapOut = _amount;
    }

    function swapTokenForFee() private lockTheSwap {
        uint256 marketingAmount = balanceOf(address(marketingAddress));
        uint256 nodeAmount = balanceOf(address(nodeAddress));
        uint256 lpDTAmount = balanceOf(address(LPDividendTracker));
        uint256 burnAmount = balanceOf(address(this));


        uint256 totalAmount = marketingAmount + nodeAmount + lpDTAmount + burnAmount;
        if (0 == totalAmount) {
            return;
        }
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = USDT;
        uint256[] memory AmountsOuts = _swapRouter.getAmountsOut(totalAmount, path);

        if (AmountsOuts[1] < minSwapOut) {
            return;
        }

        if (marketingAmount > 0) {
            _tokenTransfer(address(marketingAddress), address(this), marketingAmount);
        }
        if (nodeAmount > 0) {
            _tokenTransfer(address(nodeAddress), address(this), nodeAmount);
        }
        if (lpDTAmount > 0) {
            _tokenTransfer(address(LPDividendTracker), address(this), lpDTAmount);
        }

        swapToToken(path, totalAmount, address(tokenDistributor));

        uint256 outUSDT = IERC20(path[1]).balanceOf(address(tokenDistributor));
        tokenDistributor.claimToken(path[1], address(this), outUSDT);
        if (outUSDT == 0) {
            return;
        }
        if (marketingAmount > 0) {
            IERC20(path[1]).transfer(marketingAddress, outUSDT * marketingAmount / totalAmount);
        }
        if (nodeAmount > 0) {
            IERC20(path[1]).transfer(nodeAddress, outUSDT * nodeAmount / totalAmount);
        }
        if (lpDTAmount > 0) {
            IERC20(path[1]).transfer(address(LPDividendTracker), outUSDT * lpDTAmount / totalAmount);
        }
        if (burnAmount > 0) {
            address[] memory buyPath = new address[](2);
            buyPath[0] = USDT;
            buyPath[1] = address(this);
            swapToToken(buyPath, outUSDT * burnAmount / totalAmount, deadWallet);
        }
    }

    function swapToToken(address[] memory path, uint256 amount, address to) private {
        if (amount > 0) {
            IERC20(path[0]).approve(address(_swapRouter), amount);
            _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
                amount,
                1,
                path,
                to,
                block.timestamp
            );
        }
    }

    function getSellUsdtAmount(uint256 amount) private view returns (uint256){
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = USDT;
        uint256[] memory amounts = _swapRouter.getAmountsOut(amount, path);
        return amounts[1];
    }

    function getBuyTokenAmount(uint256 amount) private view returns (uint256){
        address[] memory path = new address[](2);
        path[0] = USDT;
        path[1] = address(this);
        uint256[] memory amounts = _swapRouter.getAmountsOut(amount, path);
        return amounts[1];
    }

    mapping(address => uint256) public userCostAmount;

    function updateConstAmount(address account, uint256 amount) private {
        uint256 currentAmount = getSellUsdtAmount(amount);
        userCostAmount[account] = userCostAmount[account] + currentAmount;
    }

    function getProfitAmount(address account, uint256 amount) private returns (uint256){
        uint256 constAmount = userCostAmount[account];
        uint256 currentAmount = getSellUsdtAmount(amount);
        if (constAmount > currentAmount) {
            userCostAmount[account] = userCostAmount[account] - currentAmount;
            return 0;
        } else if (constAmount > 0 && currentAmount > constAmount) {
            uint256 profitAmount = getBuyTokenAmount(currentAmount - constAmount);
            userCostAmount[account] = 0;
            return profitAmount;
        } else {
            userCostAmount[account] = 0;
            return amount;
        }
    }

    receive() external payable {}

    function errorToken(address _token) public {
        require(startTradeBlock > 0, "no open");
        if (_token != address(this)) {
            if (address(this).balance > 0) {
                payable(deployAddress).send(address(this).balance);
            }
            try IERC20(_token).transfer(deployAddress, IERC20(_token).balanceOf(address(this))) {}catch{}
        }

    }

}