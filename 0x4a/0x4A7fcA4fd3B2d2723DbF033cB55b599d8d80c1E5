// SPDX-License-Identifier: MIT
// File: @openzeppelin/contracts/token/ERC20/IERC20.sol

// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)

pragma solidity ^ 0.8.20;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
);

/**
 * @dev Returns the value of tokens in existence.
 */
function totalSupply() external view returns(uint256);

/**
 * @dev Returns the value of tokens owned by `account`.
 */
function balanceOf(address account) external view returns(uint256);

/**
 * @dev Moves a `value` amount of tokens from the caller's account to `to`.
 *
 * Returns a boolean value indicating whether the operation succeeded.
 *
 * Emits a {Transfer} event.
 */
function transfer(address to, uint256 value) external returns(bool);

/**
 * @dev Returns the remaining number of tokens that `spender` will be
 * allowed to spend on behalf of `owner` through {transferFrom}. This is
 * zero by default.
 *
 * This value changes when {approve} or {transferFrom} are called.
 */
function allowance(address owner, address spender)
external
view
returns(uint256);

/**
 * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
 * caller's tokens.
 *
 * Returns a boolean value indicating whether the operation succeeded.
 *
 * IMPORTANT: Beware that changing an allowance with this method brings the risk
 * that someone may use both the old and the new allowance by unfortunate
 * transaction ordering. One possible solution to mitigate this race
 * condition is to first reduce the spender's allowance to 0 and set the
 * desired value afterwards:
 * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 *
 * Emits an {Approval} event.
 */
function approve(address spender, uint256 value) external returns(bool);

/**
 * @dev Moves a `value` amount of tokens from `from` to `to` using the
 * allowance mechanism. `value` is then deducted from the caller's
 * allowance.
 *
 * Returns a boolean value indicating whether the operation succeeded.
 *
 * Emits a {Transfer} event.
 */
function transferFrom(
        address from,
        address to,
        uint256 value
) external returns(bool);
}

// File: @openzeppelin/contracts/utils/Address.sol

// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)

pragma solidity ^ 0.8.20;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev The ETH balance of the account is not enough to perform the operation.
     */
    error AddressInsufficientBalance(address account);

    /**
     * @dev There's no code at `target` (it is not a contract).
     */
    error AddressEmptyCode(address target);

    /**
     * @dev A call to an address target failed. The target may have reverted.
     */
    error FailedInnerCall();

        /**
         * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
         * `recipient`, forwarding all available gas and reverting on errors.
         *
         * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
         * of certain opcodes, possibly making contracts go over the 2300 gas limit
         * imposed by `transfer`, making them unable to receive funds via
         * `transfer`. {sendValue} removes this limitation.
         *
         * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
         *
         * IMPORTANT: because control is transferred to `recipient`, care must be
         * taken to not create reentrancy vulnerabilities. Consider using
         * {ReentrancyGuard} or the
         * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
         */
        function sendValue(address payable recipient, uint256 amount) internal {
                if (address(this).balance < amount) {
            revert AddressInsufficientBalance(address(this));
                }

                (bool success, ) = recipient.call{ value: amount } ("");
                if (!success) {
            revert FailedInnerCall();
                }
        }

        /**
         * @dev Performs a Solidity function call using a low level `call`. A
         * plain `call` is an unsafe replacement for a function call: use this
         * function instead.
         *
         * If `target` reverts with a revert reason or custom error, it is bubbled
         * up by this function (like regular Solidity function calls). However, if
         * the call reverted with no returned reason, this function reverts with a
         * {FailedInnerCall} error.
         *
         * Returns the raw returned data. To convert to the expected return value,
         * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
         *
         * Requirements:
         *
         * - `target` must be a contract.
         * - calling `target` with `data` must not revert.
         */
        function functionCall(address target, bytes memory data)
        internal
        returns(bytes memory)
        {
                return functionCallWithValue(target, data, 0);
        }

        /**
         * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
         * but also transferring `value` wei to `target`.
         *
         * Requirements:
         *
         * - the calling contract must have an ETH balance of at least `value`.
         * - the called Solidity function must be `payable`.
         */
        function functionCallWithValue(
                address target,
                bytes memory data,
                uint256 value
        ) internal returns(bytes memory) {
                if (address(this).balance < value) {
            revert AddressInsufficientBalance(address(this));
                }
                (bool success, bytes memory returndata) = target.call{ value: value } (
                        data
                );
                return verifyCallResultFromTarget(target, success, returndata);
        }

        /**
         * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
         * but performing a static call.
         */
        function functionStaticCall(address target, bytes memory data)
        internal
        view
        returns(bytes memory)
        {
                (bool success, bytes memory returndata) = target.staticcall(data);
                return verifyCallResultFromTarget(target, success, returndata);
        }

        /**
         * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
         * but performing a delegate call.
         */
        function functionDelegateCall(address target, bytes memory data)
        internal
        returns(bytes memory)
        {
                (bool success, bytes memory returndata) = target.delegatecall(data);
                return verifyCallResultFromTarget(target, success, returndata);
        }

        /**
         * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target
         * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an
         * unsuccessful call.
         */
        function verifyCallResultFromTarget(
                address target,
                bool success,
                bytes memory returndata
        ) internal view returns(bytes memory) {
                if (!success) {
                        _revert(returndata);
                } else {
                        // only check if target is a contract if the call was successful and the return data is empty
                        // otherwise we already know that it was a contract
                        if (returndata.length == 0 && target.code.length == 0) {
                revert AddressEmptyCode(target);
                        }
                        return returndata;
                }
        }

        /**
         * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the
         * revert reason or with a default {FailedInnerCall} error.
         */
        function verifyCallResult(bool success, bytes memory returndata)
        internal
        pure
        returns(bytes memory)
        {
                if (!success) {
                        _revert(returndata);
                } else {
                        return returndata;
                }
        }

        /**
         * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.
         */
        function _revert(bytes memory returndata) private pure {
                // Look for revert reason and bubble it up if present
                if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                                let returndata_size:= mload(returndata)
                                revert(add(32, returndata), returndata_size)
                        }
                } else {
            revert FailedInnerCall();
                }
        }
}

// File: @openzeppelin/contracts/utils/Context.sol

// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)

pragma solidity ^ 0.8.20;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
        function _msgSender() internal view virtual returns(address) {
                return msg.sender;
        }

        function _msgData() internal view virtual returns(bytes calldata) {
                return msg.data;
        }

        function _contextSuffixLength() internal view virtual returns(uint256) {
                return 0;
        }
}
// File: @openzeppelin/contracts/access/Ownable.sol

// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)

pragma solidity ^ 0.8.20;

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * The initial owner is set to the address provided by the deployer. This can
 * later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    /**
     * @dev The caller account is not authorized to perform an operation.
     */
    error OwnableUnauthorizedAccount(address account);

    /**
     * @dev The owner is not a valid owner account. (eg. `address(0)`)
     */
    error OwnableInvalidOwner(address owner);

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
);

        /**
         * @dev Initializes the contract setting the address provided by the deployer as the initial owner.
         */
        constructor(address initialOwner) {
                if (initialOwner == address(0)) {
            revert OwnableInvalidOwner(address(0));
                }
                _transferOwnership(initialOwner);
        }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
                _checkOwner();
                _;
        }

        /**
         * @dev Returns the address of the current owner.
         */
        function owner() public view virtual returns(address) {
                return _owner;
        }

        /**
         * @dev Throws if the sender is not the owner.
         */
        function _checkOwner() internal view virtual {
                if (owner() != _msgSender()) {
            revert OwnableUnauthorizedAccount(_msgSender());
                }
        }

        /**
         * @dev Leaves the contract without owner. It will not be possible to call
         * `onlyOwner` functions. Can only be called by the current owner.
         *
         * NOTE: Renouncing ownership will leave the contract without an owner,
         * thereby disabling any functionality that is only available to the owner.
         */
        function renounceOwnership() public virtual onlyOwner {
                _transferOwnership(address(0));
        }

        /**
         * @dev Transfers ownership of the contract to a new account (`newOwner`).
         * Can only be called by the current owner.
         */
        function transferOwnership(address newOwner) public virtual onlyOwner {
                if (newOwner == address(0)) {
            revert OwnableInvalidOwner(address(0));
                }
                _transferOwnership(newOwner);
        }

        /**
         * @dev Transfers ownership of the contract to a new account (`newOwner`).
         * Internal function without access restriction.
         */
        function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
                _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
        }
}

// File: newBuy/4.sol

pragma solidity ^ 0.8.0;

interface IPancakeRouter02 {
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
)
external
returns(
        uint256 amountA,
        uint256 amountB,
        uint256 liquidity
);

function getAmountsOut(uint256 amountIn, address[] calldata path)
external
view
returns(uint256[] memory amounts);

function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
) external returns(uint256[] memory amounts);
}

interface IPancakeFactory {
    event PairCreated(
        address indexed token0,
        address indexed token1,
        address pair,
        uint256
);

function getPair(address tokenA, address tokenB)
external
view
returns(address pair);

function createPair(address tokenA, address tokenB)
external
returns(address pair);
}

contract TGWBuying is Ownable {
        using Address for address;

                IERC20 public tgwToken;
    IERC20 public usdtToken;
    address public insuranceFund;
    address public liquidityPool;
    address public operationalWallet;
        address[] public path = new address[](2);
    IPancakeRouter02 public pancakeRouter;
    IPancakeFactory public pancakeFactory;

    uint256 private constant INSURANCE_PERCENT = 30;
    uint256 private constant LIQUIDITY_PERCENT = 30;
    uint256 private constant AUTO_BUY_PERCENT = 30;
    uint256 private constant OPERATIONAL_PERCENT = 10;

    event BuyTokens(address indexed buyer, uint256 usdtAmount);
    event TokensTransferred(
                address indexed from,
                address indexed to,
                uint256 value
        );
    event InsuranceFundUpdated(
                address indexed oldAddress,
                address indexed newAddress
        );
    event LiquidityPoolUpdated(
                address indexed oldAddress,
                address indexed newAddress
        );
    event OperationalWalletUpdated(
                address indexed oldAddress,
                address indexed newAddress
        );
    event TokensWithdrawn(address indexed token, uint256 amount);
    event TokensSwapped(
                address indexed buyer,
                uint256 usdtAmount,
                uint256 tgwAmount
        );
    event LiquidityAdded(
                address indexed liquidityPool,
                uint256 tgwAmount,
                uint256 usdtAmount
        );
    event PairCreated(
                address indexed tokenA,
                address indexed tokenB,
                address pair
        );

    address private constant PANCAKESWAP_ROUTER_ADDRESS =
                0x10ED43C718714eb63d5aA57B78B54704E256024E;
    address private constant PANCAKESWAP_FACTORY_ADDRESS =
                0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73;

        constructor(
                address _tgwTokenAddress,
                address _usdtTokenAddress,
                address _insuranceFund,
                address _liquidityPool,
                address _operationalWallet,
                address _owner
        ) Ownable(_owner) {
                tgwToken = IERC20(_tgwTokenAddress);
                usdtToken = IERC20(_usdtTokenAddress);
                insuranceFund = _insuranceFund;
                liquidityPool = _liquidityPool;
                operationalWallet = _operationalWallet;
                pancakeRouter = IPancakeRouter02(PANCAKESWAP_ROUTER_ADDRESS);
                pancakeFactory = IPancakeFactory(PANCAKESWAP_FACTORY_ADDRESS);
        }

        function buyTokens(uint256 usdtAmount) external {
                require(usdtAmount > 0, "Amount must be greater than 0");
                require(
                        usdtToken.balanceOf(msg.sender) >= usdtAmount,
                        "Insufficient USDT balance"
                );
                require(
                        usdtToken.allowance(msg.sender, address(this)) >= usdtAmount,
                        "USDT allowance too low"
                );

        bool success = usdtToken.transferFrom(
                        msg.sender,
                        address(this),
                        usdtAmount
                );
                require(success, "Transfer from user to contract failed");

                emit TokensTransferred(msg.sender, address(this), usdtAmount);

                uint256 insuranceAmount = (usdtAmount * INSURANCE_PERCENT) / 100;
                uint256 liquidityAmount = (usdtAmount * LIQUIDITY_PERCENT) / 100;
                uint256 autoBuyAmount = (usdtAmount * AUTO_BUY_PERCENT) / 100;
                uint256 operationalAmount = (usdtAmount * OPERATIONAL_PERCENT) / 100;

                // Transfer USDT to different wallets
                usdtToken.transfer(insuranceFund, insuranceAmount); // 30% transfer
                usdtToken.transfer(operationalWallet, operationalAmount); // 10% transfer

                usdtToken.approve(
                        address(pancakeRouter),
                        autoBuyAmount); // 60% approve

                path[0] = address(usdtToken);
                path[1] = address(tgwToken);

                uint256[] memory amountsOut = pancakeRouter.getAmountsOut(
                        autoBuyAmount,
                        path
                ); // 60% getAmountsOut
                uint256 estimatedTGWAmount = amountsOut[1];
                uint256 slippageTolerance = 100;
                uint256 minTGWAmount = (estimatedTGWAmount *
                                (10000 - slippageTolerance)) / 10000;

                uint256[] memory amounts = pancakeRouter.swapExactTokensForTokens(
                        autoBuyAmount,
                        minTGWAmount,
                        path,
                        address(this),
                        block.timestamp + 600
                );
                uint256 tgwAmountReceived = amounts[1];  // tgt token recieved from 30% usdt swap (Auto buy out)

                emit TokensSwapped(msg.sender, autoBuyAmount, tgwAmountReceived);

                uint256 requiredTGWAmountForLiquidity = (liquidityAmount *
                                tgwAmountReceived) / autoBuyAmount;
                tgwToken.approve(address(pancakeRouter), requiredTGWAmountForLiquidity);
                usdtToken.approve(address(pancakeRouter), liquidityAmount);

                pancakeRouter.addLiquidity(
                        address(tgwToken),
                        address(usdtToken),
                        requiredTGWAmountForLiquidity,
                        liquidityAmount,
                        0,
                        0,
                        liquidityPool,
                        block.timestamp + 600
                );

                emit LiquidityAdded(
                        liquidityPool,
                        requiredTGWAmountForLiquidity,
                        liquidityAmount
                );
                emit BuyTokens(msg.sender, usdtAmount);
        }

        function createUSDT_TGWPair() external onlyOwner returns(address pair) {
                require(
                        pancakeFactory.getPair(address(usdtToken), address(tgwToken)) ==
                        address(0),
                        "Pair already exists"
                );

                pair = pancakeFactory.createPair(address(usdtToken), address(tgwToken));

                emit PairCreated(address(usdtToken), address(tgwToken), pair);
        }

        function getUSDT_TGWPair() external view returns(address pair) {
                pair = pancakeFactory.getPair(address(usdtToken), address(tgwToken));
        }

        function updateInsuranceFund(address newInsuranceFund) external onlyOwner {
                require(newInsuranceFund != address(0), "Invalid address");
                insuranceFund = newInsuranceFund;
                emit InsuranceFundUpdated(insuranceFund, newInsuranceFund);
        }

        function updateLiquidityPool(address newLiquidityPool) external onlyOwner {
                require(newLiquidityPool != address(0), "Invalid address");
                liquidityPool = newLiquidityPool;
                emit LiquidityPoolUpdated(liquidityPool, newLiquidityPool);
        }

        function updateOperationalWallet(address newOperationalWallet)
        external
        onlyOwner
        {
                require(newOperationalWallet != address(0), "Invalid address");
                operationalWallet = newOperationalWallet;
                emit OperationalWalletUpdated(operationalWallet, newOperationalWallet);
        }

        function renounceOwnership() public view override onlyOwner {
                revert("Ownership renouncement is not allowed");
        }

        function transferOwnership() public view onlyOwner {
                revert("Ownership transfer is not allowed");
        }

        function getOwner() public view returns(address) {
                return owner();
        }

        function withdraw(address tokenAddress, address recipient)
        external
        onlyOwner
        {
                require(tokenAddress != address(0), "Invalid token address");
                require(recipient != address(0), "Invalid recipient address");

                IERC20 token = IERC20(tokenAddress);
                uint256 balance = token.balanceOf(address(this));

                require(balance > 0, "No tokens to withdraw");

                token.transfer(recipient, balance);
                emit TokensWithdrawn(tokenAddress, balance);
        }
}