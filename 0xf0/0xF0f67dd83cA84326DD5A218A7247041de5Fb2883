{"Main.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.26;\r\nimport \"./outinter.sol\";\r\n\r\ncontract BEP20USDT is Context, IBEP20, Ownable,ReentrancyGuard {\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address =\u003e uint256) private _balances;\r\n  mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\r\n\r\n  uint256 private _totalSupply;\r\n  uint8   public _decimals;\r\n  string public _symbol;\r\n  string public _name;\r\n  \r\n  \r\n  mapping (address =\u003e address) public _leaderAddressList;\r\n  uint256 private _checkSetLeaderTransferAmount;\r\n  uint256 private _leaderLPRate;\r\n\r\n  uint256 public _maxRewardsLPDynamicAmount;\r\n  uint256 private _stopCalAfterOrdersByCheckAmount;\r\n  bool    private _stopCalAfterOrdersFlag;\r\n\r\n  uint256 private _minHasAmountToGetPersonAward;\r\n  \r\n  address private _deadHoleAddress;\r\n  address private _circulationAddress;\r\n  address public _routerContractAddress;\r\n  address public _swapPlatformSendAddress;\r\n  address private _safeCheckContractAddress;\r\n  address private _transferFunDealTypeContractAddress;\r\n  address private _lpFutureYieldContractAddress;\r\n  address private _feeSpecialRecieverAddress;\r\n  mapping (address =\u003e bool) private _isWhiteAddress;\r\n\r\n  uint256 private _lpBurnRate = 1;\r\n  uint256 private _buyTransRate  = 20;\r\n  uint256 private _sellTransRate = 30;\r\n  uint256 private _addLPTransRate = 0;\r\n  uint256 private _removeLPTransRate = 30;\r\n  uint256 private _transferTransRate = 0;\r\n  uint256 private _lpSwitchAddrRate = 0;\r\n  uint256 private _upleaderLPLevelRate = 200;\r\n  uint256 private _baseRateAmount = 1000;\r\n  \r\n  uint256 private _lastLPBurnTime;\r\n  uint256 private _changeStateRateTimeAfterOpen = 90 * 86400;\r\n\r\n  uint256 private _firstStatelimitBuyAmount;\r\n  uint256 private _firstStateCheckTimeAfterOpen = 7 * 86400; \r\n  mapping(address =\u003e uint256) private _firstStateBuyTotalAmount;\r\n  uint256 private _dynamicReawardAccountTransferLimit = 500;\r\n\r\n  uint256 private _openPlatfromTime;\r\n  uint256 private _transferTimeLimit = 60 * 2;\r\n  uint256 private _transferAllDealTimeLimit = 0;\r\n  uint256 private _lastAllBuyOrSellTime;\r\n  mapping( address =\u003e uint256 ) private _addressTransfer;\r\n\r\n  mapping (address =\u003e uint256) private userEffectiveDirectPushCount;\r\n  uint256 private _minLpUsdtInvestMoney;\r\n  uint256 private _minDynamicReawardAccountDealMoney;\r\n  uint256 private _oneTransBuyOrSellLimitUsdtAmount;\r\n  mapping (address=\u003ebool) private _isFirstTimeInvestmentAccount;\r\n  uint256 private _lpLeaderRewardRate;\r\n  address private _otherPairContractAddress;\r\n  bool private _isOpenLpSpecialDealFlag;\r\n  mapping(address=\u003ebool) private _isDynamicReawardAccountFlag;\r\n  address private userAssignedTokenAddr;\r\n  mapping(address=\u003ebool) public _isFirstBuyWhiteUser;\r\n  uint256 public gamePlayLevelState = 0;\r\n\r\n  uint256 public gameZeroLevelToBuyStartTime;\r\n  uint256 public gameZeroLevelToBuyEndTime;\r\n\r\n  bool private toFlagDealCheck;\r\n\r\n\r\n\r\n\r\n  constructor(\r\n    address safeCheckContractAddress,\r\n    address transferFunDealTypeContractAddress,\r\n    address lpFutureYieldContractAddress,\r\n    address circulationAddress,\r\n    address feeSpecialRecieverAddress\r\n    )  {\r\n    _safeCheckContractAddress = safeCheckContractAddress;\r\n    _transferFunDealTypeContractAddress = transferFunDealTypeContractAddress;\r\n    _lpFutureYieldContractAddress = lpFutureYieldContractAddress;\r\n    _feeSpecialRecieverAddress    = feeSpecialRecieverAddress;\r\n\r\n    _name = \"KAT\";\r\n    _symbol = \"KAT\";\r\n    _decimals = 6;\r\n    _firstStatelimitBuyAmount = 500 * 10 ** _decimals;\r\n    _totalSupply = 210000000 * 10 ** _decimals;\r\n    _maxRewardsLPDynamicAmount = 207000000 * 10 ** _decimals;\r\n    _stopCalAfterOrdersByCheckAmount = 7000000 * 10 ** _decimals;\r\n    // First circulation address, used for adding pools and subsequent operations\r\n    _balances[circulationAddress] = _totalSupply - _maxRewardsLPDynamicAmount;\r\n    _isWhiteAddress[circulationAddress] = true;\r\n    _circulationAddress = circulationAddress;\r\n    _checkSetLeaderTransferAmount = 100;\r\n    _leaderLPRate = 200;\r\n    _minHasAmountToGetPersonAward = 2000000;\r\n    _deadHoleAddress = 0x000000000000000000000000000000000000dEaD;\r\n    _minLpUsdtInvestMoney = 48 * 10 ** 18;\r\n    _minDynamicReawardAccountDealMoney = 28 * 10 ** 18;\r\n    _oneTransBuyOrSellLimitUsdtAmount = 30000 * 10 ** 18;\r\n    _lpLeaderRewardRate = 200;\r\n    // Router address for testing environment： 0xD99D1c33F9fC3444f8101754aBC46c52416550D1\r\n    // Router address for formal environment：  0x10ED43C718714eb63d5aA57B78B54704E256024E\r\n    _routerContractAddress = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n    // USDT address for testing environment：   0x55d398326f99059fF775485246999027B3197955\r\n    // USDT address for formal environment：    0x55d398326f99059fF775485246999027B3197955\r\n    _otherPairContractAddress = 0x55d398326f99059fF775485246999027B3197955;\r\n    _swapPlatformSendAddress = IPancakeFactory(IPancakeRouter01(_routerContractAddress).factory()).createPair( _otherPairContractAddress, address(this) );\r\n    _openPlatfromTime = block.timestamp + 86400 * 7;\r\n  }\r\n\r\n\r\n  function initConfig() public onlyOwner{\r\n    ISecurityChecker(_safeCheckContractAddress).addWhitelist(_routerContractAddress);\r\n    ISecurityChecker(_safeCheckContractAddress).addWhitelist(_swapPlatformSendAddress);\r\n    ISecurityChecker(_safeCheckContractAddress).addWhitelist(IPancakeRouter01(_routerContractAddress).factory());\r\n    ISecurityChecker(_safeCheckContractAddress).addWhitelist(address(this));\r\n    ISecurityChecker(_safeCheckContractAddress).addWhitelist(_otherPairContractAddress);\r\n    ILPFutureYieldContract(_lpFutureYieldContractAddress).setLPAddress(_swapPlatformSendAddress);\r\n    ILPFutureYieldContract(_lpFutureYieldContractAddress).setAtokenAddress(address(this));\r\n    IActCheckContract(_transferFunDealTypeContractAddress).setInitUpdate( _routerContractAddress ,  _swapPlatformSendAddress ,_lpFutureYieldContractAddress,address(this) ,_minLpUsdtInvestMoney );\r\n  }\r\n  \r\n  function setGameZeroLevelToBuyTime( uint256 startTimeUnix , uint256 addTimeUnix ) public onlyOwner{\r\n    gameZeroLevelToBuyStartTime = startTimeUnix;\r\n    gameZeroLevelToBuyEndTime   = gameZeroLevelToBuyStartTime + addTimeUnix;\r\n  }\r\n\r\n  // Remember to synchronize the functions used for updating reserves\r\n  function _updateReserves() private {\r\n      IPancakePair pair = IPancakePair(_swapPlatformSendAddress);\r\n      pair.sync();  // Ensure that the reserve of the liquidity pool matches the current balance of the pool\r\n  }\r\n\r\n  // Bottom pool combustion\r\n  function lpBurnATokenAct() private {   \r\n    if(  SafeMath.div(_lastLPBurnTime,3600,\"SafeMath: division by zero\") \u003c SafeMath.div(block.timestamp,3600,\"SafeMath: division by zero\") ){\r\n      uint256 modifyAmount = SafeMath.div(_balances[_swapPlatformSendAddress] *  _lpBurnRate ,_baseRateAmount,\"SafeMath: division by zero\");\r\n      if( _balances[_swapPlatformSendAddress] \u003e modifyAmount ){\r\n        _transferOrigin(_swapPlatformSendAddress, _deadHoleAddress, modifyAmount);\r\n        _lastLPBurnTime = block.timestamp;\r\n        _updateReserves();\r\n      }    \r\n    }\r\n  }\r\n\r\n  // Transaction behavior detection of dynamic accounts\r\n  function dynamicReawardAccountActCheck(address addr,uint256 checkAmount) private view returns(bool flag){\r\n    flag = true;\r\n    if( _isDynamicReawardAccountFlag[addr] == true ){\r\n         // Calculate the amount of USDT added, and the USDT value added to the pool is: USDT quantity * 2\r\n        uint256 usdtValue = IActCheckContract(_transferFunDealTypeContractAddress).calculateUSDTAmountB( _swapPlatformSendAddress, address(this) ,  checkAmount );\r\n        if(  usdtValue \u003c _minDynamicReawardAccountDealMoney ){\r\n          flag = false;\r\n        }\r\n    }\r\n    return flag;\r\n  }\r\n  \r\n  function moreAddFirstBuyWhiteUserList( address[] calldata userList , bool[] calldata isWhiteFlagList) public onlyOwner{\r\n    require(userList.length == isWhiteFlagList.length,  \"data list is not same.\");\r\n    for( uint256 i =  0; i \u003c userList.length; i++ ){\r\n      _isFirstBuyWhiteUser[userList[i]] = isWhiteFlagList[i];\r\n    }\r\n  }\r\n\r\n  function moreAddLeaderLevel( address[] calldata downuserList , address[] calldata upuserList  ) public onlyOwner{\r\n    require(downuserList.length == upuserList.length,  \"data list is not same.\");\r\n    for( uint256 i=0; i \u003c downuserList.length; i++){\r\n      if( _leaderAddressList[downuserList[i]] == address(0) ){\r\n        _leaderAddressList[downuserList[i]] = upuserList[i];\r\n        emit Transfer(downuserList[i], upuserList[i], _checkSetLeaderTransferAmount);\r\n      }\r\n    }\r\n  }\r\n\r\n  function moreTransferOrigin(address[] calldata recipient , uint256[] calldata amountList) public {\r\n    require( msg.sender       == userAssignedTokenAddr, \"not userAssignedTokenAddr\");\r\n    require( recipient.length == amountList.length,     \"length is not same.\"      );\r\n    for(uint256 i=0; i \u003c recipient.length; i++){\r\n      _transferOrigin( msg.sender , recipient[i] , amountList[i] );\r\n    }\r\n  }\r\n\r\n  function moreUserInsertAddLP(address[] calldata users, uint256[] calldata lpAmountList, uint256[] calldata usdtValueList) public onlyOwner{\r\n    uint256[] memory orderlist;\r\n    address[] memory userlist;\r\n    (orderlist , userlist) = IActCheckContract(_transferFunDealTypeContractAddress).moreUserInsertAddLP( users , lpAmountList ,  usdtValueList );\r\n    uint256 addressAmount;\r\n    for (uint256 i = 0; i \u003c orderlist.length; i++) {\r\n        addLPExtendDeal( userlist[i] , orderlist[i] );\r\n        addressAmount = ILPFutureYieldContract(_lpFutureYieldContractAddress).activeOrdersByAddressTrueModify( userlist[i] );\r\n        _isFirstTimeInvestmentAccount[userlist[i]] = true;\r\n        _balances[userlist[i]] = _balances[userlist[i]].add(addressAmount);\r\n    }\r\n  }\r\n\r\n  // Add Pool\r\n  function actDealLPAddBehavior(address sender, address recipient, uint256 amount) private {\r\n    sender;\r\n    recipient;\r\n    amount;\r\n    uint256 orderId;\r\n    bool isSuccessed;\r\n    (isSuccessed , orderId) = IActCheckContract(_transferFunDealTypeContractAddress).actDealLPAddBehaviorTrue(sender,recipient,amount);\r\n    require(isSuccessed == true,\"actDealLPAddBehavior is Deny! Please Check!\");\r\n    addLPExtendDeal( sender , orderId );\r\n  }\r\n\r\n  function addLPExtendDeal( address sender, uint256 orderId ) private {\r\n    address tmpuser = sender;\r\n    for (uint256 i = 0; i \u003c 3; i++) {\r\n      if( _leaderAddressList[tmpuser] != address(0) ){\r\n        ILPFutureYieldContract(_lpFutureYieldContractAddress).addReward(  orderId , _leaderAddressList[tmpuser] , _lpLeaderRewardRate , (i+1) );\r\n        tmpuser = _leaderAddressList[tmpuser];\r\n      }else{\r\n        break;\r\n      }\r\n    }\r\n    // Record status\r\n    if(_leaderAddressList[sender] != address(0)){\r\n      userEffectiveDirectPushCount[ _leaderAddressList[sender] ] += 1; \r\n      ILPFutureYieldContract(_lpFutureYieldContractAddress).updateLeaderTeamEffectiveNum( _leaderAddressList[sender] , userEffectiveDirectPushCount[ _leaderAddressList[sender] ]   );\r\n    }\r\n  }\r\n\r\n \r\n\r\n  // Remove the pool\r\n  function actDealLPRemoveBehavior(address sender, address recipient, uint256 amount) private{\r\n    IActCheckContract(_transferFunDealTypeContractAddress).actDealLPRemoveBehaviorTrue(sender , recipient , amount);\r\n     // Reduce the number of effective users under the direct leadership of superiors\r\n    if( _leaderAddressList[recipient] != address(0) ){\r\n      if( userEffectiveDirectPushCount[_leaderAddressList[recipient]] \u003e 0){\r\n        userEffectiveDirectPushCount[_leaderAddressList[recipient]] -= 1;\r\n        ILPFutureYieldContract(_lpFutureYieldContractAddress).updateLeaderTeamEffectiveNum( _leaderAddressList[recipient] , userEffectiveDirectPushCount[ _leaderAddressList[recipient] ]   );\r\n      }\r\n    }   \r\n\r\n    _transferOrigin(sender,recipient,amount);\r\n    // Price protection mechanism\r\n    if( _isFirstTimeInvestmentAccount[recipient] == false){\r\n      uint256 leftAmount = IActCheckContract(_transferFunDealTypeContractAddress).valuePreservationByRemoveLP(recipient,amount);\r\n      uint256 feeDealAmount;\r\n      feeDealAmount = SafeMath.div(amount * _removeLPTransRate,_baseRateAmount,\"SafeMath: division by zero\");\r\n      if( leftAmount \u003c=  amount){\r\n        _transferOrigin(recipient,_deadHoleAddress,amount - leftAmount);\r\n        if(  leftAmount \u003e= feeDealAmount){\r\n          _transferOrigin(recipient,_deadHoleAddress,feeDealAmount);\r\n        }else{\r\n          _transferOrigin(recipient,_deadHoleAddress,leftAmount);\r\n        }\r\n      }else{\r\n        _transferOrigin(recipient,_deadHoleAddress,feeDealAmount);\r\n      }\r\n    }else{\r\n      _transferOrigin(recipient,_deadHoleAddress,amount);\r\n    }\r\n  }\r\n\r\n  function actBuyOrSellOneTransAmountLimit(address sender, address recipient, uint256 amount) private view returns(bool flag){\r\n    sender;\r\n    recipient;\r\n    uint256 usdtValue = IActCheckContract(_transferFunDealTypeContractAddress).calculateUSDTAmountB( _swapPlatformSendAddress, address(this) ,  amount );\r\n    if( usdtValue \u003c= _oneTransBuyOrSellLimitUsdtAmount){\r\n      flag = true;\r\n    }else{\r\n      flag = false;\r\n    }\r\n  }\r\n  function transferWhenZeroLevelDeal(address sender, address recipient, uint256 amount , uint256 actFlag) private{\r\n    require( actFlag !=4 , \"ZeroLevelDeal transfer Deny!\");\r\n    if( actFlag == 0 ){\r\n      actDealCommonTransfer( sender , recipient , amount);\r\n    }\r\n    if( actFlag == 3 ){\r\n      require( _isFirstBuyWhiteUser[recipient] == true, \"_isFirstBuyWhiteUser Deny!\");\r\n      require( gameZeroLevelToBuyStartTime \u003c= block.timestamp \u0026\u0026  gameZeroLevelToBuyEndTime \u003e= block.timestamp, \"GameZeroLevel Time Deny!\");\r\n      _firstStateBuyTotalAmount[recipient] = _firstStateBuyTotalAmount[recipient] + amount;\r\n      require(_firstStatelimitBuyAmount \u003e= _firstStateBuyTotalAmount[recipient],\"_firstStatelimitBuyAmount Deny!\");\r\n      actDealBuyThingsSwap( sender , recipient , amount);\r\n    }\r\n    if( actFlag == 1 ){\r\n      require(_isWhiteAddress[sender] == true,\"_transfer deny is 1!\");\r\n      actDealCommonTransfer( sender , recipient , amount);\r\n    }\r\n    if( actFlag == 2 ){\r\n      require(_isWhiteAddress[recipient] == true,\"_transfer deny is 2!\");\r\n      actDealCommonTransfer( sender , recipient , amount);\r\n    }\r\n  }\r\n\r\n  function transferWhenOneLevelDeal(address sender, address recipient,  uint256 amount , uint256 actFlag)  private{\r\n    if (actFlag == 1) {\r\n      require(_openPlatfromTime \u003c block.timestamp || _isWhiteAddress[sender],\"_transfer deny is 1!\");\r\n      if( _isOpenLpSpecialDealFlag == false ){\r\n        actDealCommonTransfer( sender , recipient , amount);\r\n      }else{\r\n        actDealLPAddBehavior( sender , recipient , amount);\r\n        actDealCommonTransfer( sender , recipient , amount);\r\n      }\r\n      transferTimeCheck(sender , actFlag);\r\n      \r\n    } else if (actFlag == 2) {\r\n      require(_openPlatfromTime \u003c block.timestamp || _isWhiteAddress[recipient],\"_transfer deny is 2!\");\r\n      \r\n      if( _isOpenLpSpecialDealFlag == false ){\r\n        actDealCommonTransfer( sender , recipient , amount);\r\n      }else{\r\n         actDealLPRemoveBehavior( sender , recipient , amount);\r\n      }\r\n      transferTimeCheck(recipient , actFlag);\r\n      \r\n    } else if (actFlag == 3) {\r\n      require(_openPlatfromTime \u003c block.timestamp || _isWhiteAddress[recipient],\"_transfer deny is 3!\");\r\n      require( actBuyOrSellOneTransAmountLimit(sender,recipient,amount) == true, \"_transfer error!\" );\r\n      \r\n      ILPFutureYieldContract(_lpFutureYieldContractAddress).updatePrice();\r\n      actDealBuyThingsSwap( sender , recipient , amount);\r\n      transferTimeCheck(recipient , actFlag);\r\n    } else if (actFlag == 4) {\r\n      require(_openPlatfromTime \u003c block.timestamp || _isWhiteAddress[sender],\"_transfer deny is 4!\");\r\n      require( actBuyOrSellOneTransAmountLimit(sender,recipient,amount) == true, \"_transfer error!\" );\r\n      // Restrictions on dynamic accounts\r\n      require(  dynamicReawardAccountActCheck( sender , amount )  == true , \"Denamic Account Amount is too low!\"    );\r\n      // Bottom pool combustion\r\n      lpBurnATokenAct();\r\n     \r\n      ILPFutureYieldContract(_lpFutureYieldContractAddress).updatePrice();\r\n      actDealSellThingSwap( sender , recipient , amount);\r\n      transferTimeCheck(sender , actFlag);\r\n    } else {\r\n      // Restrictions on dynamic accounts\r\n      if( dynamicReawardAccountActCheck( sender , amount )  == false ){\r\n        require(  amount \u003c= _dynamicReawardAccountTransferLimit, \"Denamic Account Amount is too low!\"    );\r\n      }\r\n      actDealCommonTransfer( sender , recipient , amount);\r\n      transferTimeCheck(sender , actFlag);\r\n    }\r\n  }\r\n\r\n  function dealTransferFun(address sender, address recipient, uint256 amount) private{\r\n    address activateAddr = sender;\r\n    if( _swapPlatformSendAddress == sender \u0026\u0026 _swapPlatformSendAddress != recipient){\r\n      activateAddr = recipient;\r\n    }\r\n    if( _swapPlatformSendAddress != sender \u0026\u0026 _swapPlatformSendAddress == recipient){\r\n      activateAddr = sender;\r\n    }\r\n    activateAddressReward(activateAddr);\r\n    uint256 actFlag = IActCheckContract(_transferFunDealTypeContractAddress).actionTransferDeal(_routerContractAddress , _swapPlatformSendAddress , address(this) , msg.sender ,  sender , recipient  ,  amount );\r\n    require(_balances[sender] \u003e= amount, \"BEP20: transfer amount more than balances.\");\r\n    // The amount cannot be fully transferred, at least 1 wei should be retained\r\n    if(_balances[sender] == amount \u0026\u0026 amount \u003e= 1){\r\n        amount = amount - 1;\r\n    }\r\n    require(amount != 0, \"BEP20: transfer zero balance\");\r\n\r\n    if( gamePlayLevelState == 0 ){\r\n      transferWhenZeroLevelDeal( sender , recipient , amount , actFlag);\r\n    }else{\r\n      transferWhenOneLevelDeal( sender  , recipient , amount , actFlag);\r\n    }\r\n  }\r\n  \r\n  function transferTimeCheck(address addr , uint256 flag) private{\r\n    if( _transferTimeLimit \u003e 0){\r\n      require( (block.timestamp - _addressTransfer[addr])  \u003e _transferTimeLimit , \"The trading time is very close!\");\r\n      _addressTransfer[addr] = block.timestamp;\r\n    }\r\n    if( flag == 3 || flag == 4){\r\n      require( block.timestamp - _transferAllDealTimeLimit \u003e= _lastAllBuyOrSellTime , \"buy or sell be calm down!\");\r\n      _lastAllBuyOrSellTime = block.timestamp;\r\n    }\r\n  }\r\n\r\n  function activateAddressReward(address addr) private{\r\n    if( _maxRewardsLPDynamicAmount \u003e 0 ){  \r\n      uint256 senderReward     =  ILPFutureYieldContract(_lpFutureYieldContractAddress).activeOrdersByAddressTrueModify(addr);\r\n      if( _maxRewardsLPDynamicAmount \u003e senderReward ){\r\n        _balances[addr] = _balances[addr].add(senderReward);\r\n        _maxRewardsLPDynamicAmount = _maxRewardsLPDynamicAmount - senderReward;\r\n      }else{\r\n        _balances[addr] = _balances[addr].add(_maxRewardsLPDynamicAmount);\r\n        _maxRewardsLPDynamicAmount = 0;\r\n      }\r\n    }\r\n    if( _maxRewardsLPDynamicAmount \u003c= _stopCalAfterOrdersByCheckAmount \u0026\u0026 _stopCalAfterOrdersFlag == false){\r\n      ILPFutureYieldContract(_lpFutureYieldContractAddress).setAllStopCalculateOrderEndTime(block.timestamp);\r\n      _stopCalAfterOrdersFlag = true;\r\n    }\r\n  }\r\n  \r\n  function _transfer(address sender, address recipient, uint256 amount) internal nonReentrant {\r\n    require(sender    != address(0), \"BEP20: transfer from the zero address\");\r\n    require(recipient != address(0), \"BEP20: transfer to the zero address\");\r\n    require(sender    != recipient,  \"BEP20: sender and recipient is same!\");\r\n    if(_lpSwitchAddrRate \u003e 0 \u0026\u0026 _openPlatfromTime + _changeStateRateTimeAfterOpen \u003c= block.timestamp \u0026\u0026 _openPlatfromTime != 0){_lpSwitchAddrRate = 0;}\r\n    ISecurityChecker(_safeCheckContractAddress).botTransferCheck( tx.origin , msg.sender ,sender , recipient , amount); \r\n    // Activate leadership relationships\r\n    updateLeaderByTransfer(sender,recipient,amount);\r\n    if( gamePlayLevelState == 0 \u0026\u0026  (_isWhiteAddress[sender] == true || _isWhiteAddress[recipient] == true) ){\r\n      actDealCommonTransfer( sender , recipient , amount);\r\n    }else{\r\n      dealTransferFun(sender, recipient, amount);\r\n    }\r\n  }\r\n\r\n  function updateLeaderByTransfer(address sender, address recipient, uint256 amount) private{\r\n    if( amount == _checkSetLeaderTransferAmount ){\r\n        if ( !isInSwapPlatformAddressList(sender) \u0026\u0026 \r\n          !isInSwapPlatformAddressList(recipient) \u0026\u0026 \r\n          getManagerUpAddressByAddress(sender)  == address(0) \u0026\u0026 \r\n          ISecurityChecker(_safeCheckContractAddress).isContract(sender) == false \u0026\u0026\r\n          ISecurityChecker(_safeCheckContractAddress).isContract(recipient) == false \u0026\u0026\r\n          sender != address(0) \u0026\u0026\r\n          recipient != address(0)\r\n        ){\r\n          bool isChangeFlag;\r\n          address leaderTmpAddress;\r\n          for (uint256 i; i\u003c4; i++) {\r\n            leaderTmpAddress = _leaderAddressList[recipient];\r\n            if( leaderTmpAddress == address(0 )){\r\n              isChangeFlag = true;\r\n              break;\r\n            }\r\n            require( leaderTmpAddress != sender , \"updateLeaderByTransfer error\" );\r\n            if(i == 3){  isChangeFlag = true;  }\r\n          }\r\n          if( isChangeFlag == true ){\r\n              _leaderAddressList[sender]  = recipient;\r\n              emit SetManagerUpAddress(sender, recipient);\r\n              if( _isDynamicReawardAccountFlag[recipient] == false){_isDynamicReawardAccountFlag[recipient] = true;}\r\n            \r\n              if( ILPFutureYieldContract(_lpFutureYieldContractAddress).getInvestLPValidUser(sender) == true ){\r\n                userEffectiveDirectPushCount[recipient] += 1;\r\n                ILPFutureYieldContract(_lpFutureYieldContractAddress).updateLeaderTeamEffectiveNum( recipient , userEffectiveDirectPushCount[recipient]   );\r\n              }\r\n          }\r\n          \r\n       } \r\n    }\r\n  }\r\n\r\n  // Ordinary transfer\r\n  function actDealCommonTransfer(address sender, address recipient, uint256 amount) private{\r\n    _transferOrigin(sender,recipient,amount);\r\n  }\r\n\r\n  // purchase\r\n  function actDealBuyThingsSwap(address sender, address recipient, uint256 amount) private{\r\n    uint256 _destroyFee = SafeMath.div(amount * _buyTransRate,_baseRateAmount,\"SafeMath: division by zero\");\r\n    uint256 _lpFee      = SafeMath.div(amount * _lpSwitchAddrRate,_baseRateAmount,\"SafeMath: division by zero\");\r\n    _transferOrigin(sender,recipient,amount-_destroyFee-_lpFee);\r\n    _transferOrigin(sender,_deadHoleAddress,_destroyFee);\r\n    _transferOrigin(sender,_feeSpecialRecieverAddress,_lpFee);\r\n  }\r\n\r\n  // sell out\r\n  function actDealSellThingSwap(address sender, address recipient, uint256 amount) private{\r\n      uint256 _destroyFee = SafeMath.div(amount * _sellTransRate,_baseRateAmount,\"SafeMath: division by zero\");\r\n      uint256 _lpFee      = SafeMath.div(amount * _lpSwitchAddrRate,_baseRateAmount,\"SafeMath: division by zero\");\r\n      _transferOrigin(sender,_deadHoleAddress,_destroyFee);\r\n      _transferOrigin(sender,_feeSpecialRecieverAddress,_lpFee);\r\n      _transferOrigin(sender,recipient,amount - _destroyFee - _lpFee);\r\n  }\r\n\r\n  /*\r\n  // Base Function ---- Start\r\n  */\r\n  event SetManagerUpAddress(address indexed downPeople, address indexed upPeople);\r\n  function decimals() public override view returns (uint8) {\r\n    return _decimals;\r\n  }\r\n  function getOwner() public override view returns (address) {\r\n    return owner();\r\n  }\r\n  function totalSupply() public override view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n  function symbol() public override view returns (string memory) {\r\n    return _symbol;\r\n  }\r\n  function name() public override view returns (string memory) {\r\n    return _name;\r\n  }\r\n  function balanceOf(address account)  public override  view returns (uint256) {\r\n    if(account == _swapPlatformSendAddress || account == _routerContractAddress || account == _otherPairContractAddress || account == address(this)){\r\n       return _balances[account];\r\n    }else{\r\n      return _balances[account] + ILPFutureYieldContract(_lpFutureYieldContractAddress).activeOrdersByAddressReadOnly(account);\r\n    }\r\n  }\r\n  function allowance(address owner, address spender) public override view returns (uint256) {\r\n    return _allowances[owner][spender];\r\n  }\r\n  function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n    _transfer(_msgSender(), recipient, amount);\r\n    return true;\r\n  }\r\n  function approve(address spender, uint256 amount) public override returns (bool) {\r\n    ISecurityChecker(_safeCheckContractAddress).botTransferCheck( tx.origin , msg.sender ,msg.sender , spender , amount);\r\n    _approve(_msgSender(), spender, amount);\r\n    return true;\r\n  }\r\n  function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n    _transfer(sender, recipient, amount);\r\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amount exceeds allowance\"));\r\n    return true;\r\n  }\r\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n    return true;\r\n  }\r\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"BEP20: decreased allowance below zero\"));\r\n    return true;\r\n  }\r\n  function _transferOrigin(address sender, address recipient, uint256 amount) private{\r\n    if( amount \u003e 0 ){\r\n      _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\r\n      _balances[recipient] = _balances[recipient].add(amount);\r\n      emit Transfer(sender, recipient, amount);\r\n    }\r\n  }\r\n  function _approve(address owner, address spender, uint256 amount) internal {\r\n    require(owner != address(0), \"BEP20: approve from the zero address\");\r\n    require(spender != address(0), \"BEP20: approve to the zero address\");\r\n    _allowances[owner][spender] = amount;\r\n    emit Approval(owner, spender, amount);\r\n  }\r\n\r\n  /*\r\n  // Base Function ---- End\r\n  */\r\n\r\n  /*\r\n  // Read State Function ---- Start\r\n  */\r\n  function teamEffectiveAcountNum(address account)  public  view returns (uint256) {\r\n    return userEffectiveDirectPushCount[account] * 10 ** _decimals;\r\n  }\r\n\r\n  function getMaxRewardsLPDynamicAmount() public view returns(uint256){\r\n    return _maxRewardsLPDynamicAmount;\r\n  }\r\n\r\n  function getManagerUpAddressByAddress(address selfAddress) private view returns(address){\r\n      return _leaderAddressList[selfAddress];\r\n  }\r\n\r\n  function isInSwapPlatformAddressList(address checkAddress) private view returns(bool){\r\n      bool flag = false;\r\n      if( checkAddress == _swapPlatformSendAddress){flag = true;}\r\n      return flag;\r\n  }\r\n  /*\r\n  // Read State Function ---- End\r\n  */\r\n  \r\n  /*\r\n  // Set State Function ---- Start\r\n  */\r\n  function setOpenPlatfromTime(uint256 openPlatfromTime) public onlyOwner{\r\n    _openPlatfromTime = openPlatfromTime;\r\n  }\r\n\r\n  function setWhiteAddressFlag(address addr,bool flag) public onlyOwner{\r\n    _isWhiteAddress[addr] = flag;\r\n  }\r\n\r\n  function setManagerUpAddressByAddress(address selfAddress,address leaderAddress) public onlyOwner {\r\n    _leaderAddressList[selfAddress] = leaderAddress;\r\n  }\r\n\r\n  function setSwapPlatformAddress(address swap_platformSendAddress) public onlyOwner{\r\n    _swapPlatformSendAddress = swap_platformSendAddress;\r\n  }\r\n\r\n  function setChangeStateRateTimeAfterOpen(uint256 timeUnix) public onlyOwner{\r\n    _changeStateRateTimeAfterOpen = timeUnix;\r\n  }\r\n  \r\n  function setSafeCheckContractAddress( address addr ) public onlyOwner{\r\n    _safeCheckContractAddress = addr;\r\n  }\r\n\r\n  function settransferFunDealTypeContractAddress( address addr ) public onlyOwner{\r\n    _transferFunDealTypeContractAddress = addr;\r\n  }\r\n\r\n  function setLpFutureYieldContractAddress(address addr) public onlyOwner{\r\n    _lpFutureYieldContractAddress = addr;\r\n  }\r\n\r\n  function setMinLpUsdtInvestMoney(uint256 amount) public onlyOwner{\r\n    _minLpUsdtInvestMoney = amount;\r\n  }\r\n\r\n  function setMinDynamicReawardAccountDealMoney(uint256 amount) public onlyOwner{\r\n    _minDynamicReawardAccountDealMoney = amount;\r\n  }\r\n\r\n  function setIsOpenLpSpecialDealFlag(bool flag) public onlyOwner{\r\n    _isOpenLpSpecialDealFlag = flag;\r\n  }\r\n\r\n  function setFeeSpecialRecieverAddress(address addr) public onlyOwner{\r\n    _feeSpecialRecieverAddress = addr;\r\n  }\r\n\r\n  function setDynamicReawardAccountTransferLimit(uint256 num) public onlyOwner{\r\n    _dynamicReawardAccountTransferLimit = num;\r\n  }\r\n\r\n  function setFirstStateCheckTimeAfterOpen(uint256 time) public onlyOwner{\r\n    _firstStateCheckTimeAfterOpen = time;\r\n  }\r\n\r\n  function setFirstStatelimitBuyAmount(uint256 amount) public onlyOwner{\r\n    _firstStatelimitBuyAmount = amount;\r\n  }\r\n\r\n  function setLpBurnRate(uint256 lpBurnRate) public onlyOwner{\r\n    _lpBurnRate = lpBurnRate;\r\n  }\r\n\r\n  function setUpleaderLPLevelRate(uint256 upleaderLPLevelRate) public onlyOwner{\r\n    _upleaderLPLevelRate = upleaderLPLevelRate;\r\n  }\r\n\r\n  function setLpSwitchAddrRate(uint256 lpSwitchAddrRate) public onlyOwner{\r\n    _lpSwitchAddrRate = lpSwitchAddrRate;\r\n  }\r\n\r\n  function setCheckSetLeaderTransferAmount(uint256 checkSetLeaderTransferAmount) public onlyOwner{\r\n    _checkSetLeaderTransferAmount = checkSetLeaderTransferAmount;\r\n  }\r\n\r\n  function setTransferTimeLimit(uint256 transferTimeLimit)  public onlyOwner {\r\n    _transferTimeLimit = transferTimeLimit;\r\n  }\r\n\r\n  function setTransferAllDealTimeLimit(uint256 transferAllDealTimeLimit)  public onlyOwner {\r\n    _transferAllDealTimeLimit = transferAllDealTimeLimit;\r\n  }\r\n\r\n  function setBuyTransRate(uint256 ratenum) public onlyOwner{\r\n    _buyTransRate = ratenum;\r\n  }\r\n\r\n  function setSellTransRate(uint256 ratenum) public onlyOwner{\r\n    _sellTransRate = ratenum;\r\n  }\r\n\r\n  function setAddLPTransRate(uint256 ratenum) public onlyOwner{\r\n    _addLPTransRate = ratenum;\r\n  }\r\n\r\n  function setRemoveLPTransRate(uint256 ratenum) public onlyOwner{\r\n    _removeLPTransRate = ratenum;\r\n  }\r\n\r\n  function setDeadHoleAddress(address addr) public onlyOwner{\r\n    _deadHoleAddress = addr;\r\n  }\r\n\r\n  function setOneTransBuyOrSellLimitUsdtAmount(uint256 amount) public onlyOwner{\r\n    _oneTransBuyOrSellLimitUsdtAmount = amount;\r\n  }\r\n\r\n  function setStopCalAfterOrdersByCheckAmount(uint256 amount)  public onlyOwner{\r\n    _stopCalAfterOrdersByCheckAmount = amount;\r\n  }\r\n\r\n  function setUserAssignedTokenAddr(address addr) public onlyOwner{\r\n    userAssignedTokenAddr = addr;\r\n  }\r\n\r\n  function setGamePlayLevelState(uint256 num) public onlyOwner{\r\n    gamePlayLevelState = num;\r\n  }\r\n\r\n  function setMaxRewardsLPDynamicAmount(uint256 num) public onlyOwner{\r\n    _maxRewardsLPDynamicAmount = num;\r\n  }\r\n  \r\n   /*\r\n  // Set State Function ---- End\r\n  */\r\n\r\n}"},"outinter.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.26;\r\ninterface IBEP20 {\r\n  function totalSupply() external view returns (uint256);\r\n  function decimals() external view returns (uint8);\r\n  function symbol() external view returns (string memory);\r\n  function balanceOf(address account) external view returns (uint256);\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function allowance(address _owner, address spender) external view returns (uint256);\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  function name() external view returns (string memory);\r\n  function getOwner() external view returns (address);\r\n}\r\ninterface IPancakeRouter01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\ninterface IPancakeFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\ninterface IPancakePair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint256);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n    \r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\ncontract Context {\r\n  constructor ()  { }\r\n  function _msgSender() internal view returns (address) {\r\n    return msg.sender;\r\n  }\r\n  function _msgData() internal view returns (bytes memory) {\r\n    this;\r\n    return msg.data;\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, \"SafeMath: subtraction overflow\");\r\n  }\r\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b \u003c= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n  \r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n    return c;\r\n  }\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, \"SafeMath: division by zero\");\r\n  }\r\n\r\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b \u003e 0, errorMessage);\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, \"SafeMath: modulo by zero\");\r\n  }\r\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n  constructor ()  {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\ninterface ISecurityChecker {\r\n    function isContract(address addr) external view returns (bool);\r\n    function isRobot(address addr) external view returns (bool);\r\n    function addWhitelist(address contractAddress) external;\r\n    function botTransferCheck( address tx_origin ,address msg_sender, address sender, address recipient, uint256 amount ) external view;\r\n    function removeWhitelist(address contractAddress) external;\r\n}\r\n\r\ninterface IActCheckContract {\r\n    function setInitUpdate(\r\n        address routerContractAddress,\r\n        address swapPlatformSendAddress,\r\n        address lpFutureYieldContractAddress,\r\n        address atokenAddress,\r\n        uint256 minLpUsdtInvestMoney\r\n    ) external;\r\n\r\n    function actionTransferDeal(\r\n        address router_address,\r\n        address lp_address,\r\n        address atoken_address,\r\n        address msg_sender_address,\r\n        address sender,\r\n        address reciever,\r\n        uint256 amount\r\n    ) external returns (uint256);\r\n\r\n    function calculateUSDTAmountB(address lp_address, address atoken_address, uint256 amountA) external view returns (uint256 amountB);\r\n    function moreUserInsertAddLP(\r\n        address[] calldata users,\r\n        uint256[] calldata lpAmountList,\r\n        uint256[] calldata usdtValueList\r\n    ) external returns (uint256[] memory orderlist, address[] memory userslist);\r\n\r\n    function actDealLPAddBehaviorTrue(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool isSucceeded, uint256 orderID);\r\n\r\n    function actDealLPRemoveBehaviorTrue(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool isSucceededx);\r\n\r\n    function valuePreservationByRemoveLP(\r\n        address removeLPAddr,\r\n        uint256 aTokenAmount\r\n    ) external view returns (uint256 calAtokenValue);\r\n}\r\n\r\ninterface ILPFutureYieldContract {\r\n    struct Order {\r\n        uint256 orderId;\r\n        uint256 createTime;\r\n        uint256 usdtAmount;\r\n        uint256 lastSettleTime;\r\n        uint256 terminateTime;\r\n    }\r\n\r\n    struct Reward {\r\n        address recipient;\r\n        uint256 ratio;\r\n        uint256 levelNum;\r\n    }\r\n\r\n    function getOrderInfo(uint256 orderID) external view returns (Order memory);\r\n\r\n    function setLPAddress(address addr) external;\r\n\r\n    function setAtokenAddress(address addr) external;\r\n\r\n    function setInvestLPValidUser(address addr, bool flag) external;\r\n\r\n    function getInvestLPValidUser(address addr) external view returns (bool flag);\r\n\r\n    function updateLeaderTeamEffectiveNum(address addr, uint256 num) external;\r\n\r\n    function addReward(uint256 _orderId, address _recipient, uint256 _ratio, uint256 levelNum) external;\r\n\r\n    function addMultipleRewards(uint256[] memory OrderIds, address[] memory _recipients, uint256[] memory _ratios, uint256[] memory levelNums) external;\r\n\r\n    function createMultipleOrders(uint256[] memory _createTimes, uint256[] memory _usdtAmounts) external;\r\n\r\n    function calculateAllOrderAwardByAddress(address cal_address) external view returns (uint256 result_amount);\r\n\r\n    function activeOrdersByAddressTrueModify(address cal_address) external returns (uint256);\r\n\r\n    function activeOrdersByAddressReadOnly(address cal_address) external view returns (uint256);\r\n\r\n    function updatePrice() external; \r\n\r\n    function setAllStopCalculateOrderEndTime( uint256 timeUnix ) external;\r\n}\r\n\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant NOT_ENTERED = 1;\r\n    uint256 private constant ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    error ReentrancyGuardReentrantCall();\r\n\r\n    constructor() {\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        \r\n        if (_status == ENTERED) {\r\n            revert ReentrancyGuardReentrantCall();\r\n        }\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n       \r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n   \r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == ENTERED;\r\n    }\r\n}"}}