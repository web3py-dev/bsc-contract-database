// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;

    interface IERC20 {
        /**
        * @dev Returns the amount of tokens in existence.
        */
        function totalSupply() external view returns (uint256);

        function symbol() external view returns(string memory);
        /**
        * @dev Returns the amount of tokens owned by `account`.
        */
        function balanceOf(address account) external view returns (uint256);
        /**
        * @dev Moves `amount` tokens from the caller's account to `recipient`.
        *
        * Returns a boolean value indicating whether the operation succeeded.
        *
        * Emits a {Transfer} event.
        */
        function transfer(address recipient, uint256 amount) external returns (bool);
        /**
        * @dev Returns the remaining number of tokens that `spender` will be
        * allowed to spend on behalf of `owner` through {transferFrom}. This is
        * zero by default.
        *
        * This value changes when {approve} or {transferFrom} are called.
        */
        function allowance(address owner, address spender)
        external
        view
        returns (uint256);

        /**
        * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
        *
        * Returns a boolean value indicating whether the operation succeeded.
        *
        * IMPORTANT: Beware that changing an allowance with this method brings the risk
        * that someone may use both the old and the new allowance by unfortunate
        * transaction ordering. One possible solution to mitigate this race
        * condition is to first reduce the spender's allowance to 0 and set the
        * desired value afterwards:
        * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
        *
        * Emits an {Approval} event.
        */
        function approve(address spender, uint256 amount) external returns (bool);

        /**
        * @dev Moves `amount` tokens from `sender` to `recipient` using the
        * allowance mechanism. `amount` is then deducted from the caller's
        * allowance.
        *
        * Returns a boolean value indicating whether the operation succeeded.
        *
        * Emits a {Transfer} event.
        */
        function transferFrom(
            address sender,
            address recipient,
            uint256 amount
        ) external returns (bool);

        /**
        * @dev Emitted when `value` tokens are moved from one account (`from`) to
        * another (`to`).
        *
        * Note that `value` may be zero.
        */
        event Transfer(address indexed from, address indexed to, uint256 value);

        /**
        * @dev Emitted when the allowance of a `spender` for an `owner` is set by
        * a call to {approve}. `value` is the new allowance.
        */
        event Approval(
            address indexed owner,
            address indexed spender,
            uint256 value
        );
    }

    
    library Address {
        function isContract(address account) internal view returns (bool) {
        // This method relies in extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
        }
    }

    contract Ownable {
        address internal _owner;

        event OwnershipTransferred(
            address indexed previousOwner,
            address indexed newOwner
        );

        /**
        * @dev Initializes the contract setting the deployer as the initial owner.
        */
        constructor() {
            address msgSender = _msgSender();
            _owner = msgSender;
            emit OwnershipTransferred(address(0), msgSender);
        }

        function _msgSender() internal view returns(address) {
            return msg.sender;
        }
        /**
        * @dev Returns the address of the current owner.
        */
        function owner() public view returns (address) {
            return _owner;
        }

        /**
        * @dev Throws if called by any account other than the owner.
        */
        modifier onlyOwner() {
            require(_owner == _msgSender(), "Ownable: caller is not the owner");
            _;
        }

        /**
        * @dev Leaves the contract without owner. It will not be possible to call
        * `onlyOwner` functions anymore. Can only be called by the current owner.
        *
        * NOTE: Renouncing ownership will leave the contract without an owner,
        * thereby removing any functionality that is only available to the owner.
        */
        function renounceOwnership() public virtual onlyOwner {
            emit OwnershipTransferred(_owner, address(0));
            _owner = address(0);
        }

        /**
        * @dev Transfers ownership of the contract to a new account (`newOwner`).
        * Can only be called by the current owner.
        */
        function transferOwnership(address newOwner) public virtual onlyOwner {
            require(
                newOwner != address(0),
                "Ownable: new owner is the zero address"
            );
            emit OwnershipTransferred(_owner, newOwner);
            _owner = newOwner;
        }
    }


    library SafeMath {
        /**
        * @dev Returns the subtraction of two unsigned integers, reverting on
        * overflow (when the result is negative).
        *
        * Counterpart to Solidity's `-` operator.
        *
        * Requirements:
        *
        * - Subtraction cannot overflow.
        */
        function sub(uint256 a, uint256 b) internal pure returns (uint256) {
            return sub(a, b, "SafeMath: subtraction overflow");
        }

        /**
        * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
        * overflow (when the result is negative).
        *
        * Counterpart to Solidity's `-` operator.
        *
        * Requirements:
        *
        * - Subtraction cannot overflow.
        */
        function sub(
            uint256 a,
            uint256 b,
            string memory errorMessage
        ) internal pure returns (uint256) {
            require(b <= a, errorMessage);
            uint256 c = a - b;

            return c;
        }

        /**
        * @dev Returns the multiplication of two unsigned integers, reverting on
        * overflow.
        *
        * Counterpart to Solidity's `*` operator.
        *
        * Requirements:
        *
        * - Multiplication cannot overflow.
        */
        function mul(uint256 a, uint256 b) internal pure returns (uint256) {
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
            // benefit is lost if 'b' is also tested.
            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
            if (a == 0) {
                return 0;
            }

            uint256 c = a * b;
            require(c / a == b, "SafeMath: multiplication overflow");

            return c;
        }

        /**
        * @dev Returns the integer division of two unsigned integers. Reverts on
        * division by zero. The result is rounded towards zero.
        *
        * Counterpart to Solidity's `/` operator. Note: this function uses a
        * `revert` opcode (which leaves remaining gas untouched) while Solidity
        * uses an invalid opcode to revert (consuming all remaining gas).
        *
        * Requirements:
        *
        * - The divisor cannot be zero.
        */
        function div(uint256 a, uint256 b) internal pure returns (uint256) {
            return div(a, b, "SafeMath: division by zero");
        }

        /**
        * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
        * division by zero. The result is rounded towards zero.
        *
        * Counterpart to Solidity's `/` operator. Note: this function uses a
        * `revert` opcode (which leaves remaining gas untouched) while Solidity
        * uses an invalid opcode to revert (consuming all remaining gas).
        *
        * Requirements:
        *
        * - The divisor cannot be zero.
        */
        function div(
            uint256 a,
            uint256 b,
            string memory errorMessage
        ) internal pure returns (uint256) {
            require(b > 0, errorMessage);
            uint256 c = a / b;
            // assert(a == b * c + a % b); // There is no case in which this doesn't hold
            return c;
        }
    }


    interface IUniswapV2Pair {
        function balanceOf(address owner) external view returns (uint256);
        function totalSupply() external view returns (uint);
        function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
        function token0() external view returns (address);
        function token1() external view returns (address);
    }

    interface IUniswapV2Factory {
         event PairCreated(address indexed token0, address indexed token1, address pair, uint);

        function feeTo() external view returns (address);
        function feeToSetter() external view returns (address);

        function getPair(address tokenA, address tokenB) external view returns (address pair);
        function allPairs(uint) external view returns (address pair);
        function allPairsLength() external view returns (uint);

        function createPair(address tokenA, address tokenB) external returns (address pair);

        function setFeeTo(address) external;
        function setFeeToSetter(address) external;
    }

    interface IUniswapV2Router01 {
        function factory() external pure returns (address);
        function WETH() external pure returns (address);
        function swapExactTokensForTokens(
            uint amountIn,
            uint amountOutMin,
            address[] calldata path,
            address to,
            uint deadline
        ) external returns (uint[] memory amounts);

        function addLiquidity(
            address tokenA,
            address tokenB,
            uint256 amountADesired,
            uint256 amountBDesired,
            uint256 amountAMin,
            uint256 amountBMin,
            address to,
            uint256 deadline
        )
        external
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        );
       
        function getAmountsOut(uint256 amountIn, address[] calldata path)
        external
        view
        returns (uint256[] memory amounts);
    }

    interface IUniswapV2Router02 is IUniswapV2Router01 {
        
        function swapExactTokensForTokensSupportingFeeOnTransferTokens(
            uint256 amountIn,
            uint256 amountOutMin,
            address[] calldata path,
            address to,
            uint256 deadline
        ) external;
    }

    contract TokenDistributor {
        address public _owner;
        constructor() {
            _owner = msg.sender;
        }
        function claimToken(address _token,uint256 _amount,address _to) external {
            require(_owner == msg.sender);
            IERC20(_token).transfer(_to,_amount);
        } 
    }

contract OpenMinePool is Ownable{
    using SafeMath for uint256;
    uint256 public startTime;
    //是否已经正常开启
    bool private isOpen;
    uint256[] public level;
    uint256 private initPower = 100;
    uint256 private dayPower = 1;
    uint256 public firstNum = 16000e18;
    uint256 public firstDayLong = 30 days;
    uint256 public usualNum = 1500e18;
    uint256 public minShareU = 100e18;
    uint256 public countPower;
    uint256 public temp = 10e18;
    mapping(address => Share) public shareInfos;
    struct Share {
        uint256 power;
        uint256 totalValue;
    }
    uint256 public nextSettleBlock;

    address[] private allUser;
    mapping(address => address) public bindAddress;
    mapping(address => Invite) public inviteInfos;
    struct Invite {
        uint256 num;
        uint256 power;
    }
    mapping(address => Reward) public rewardInfos;
    struct Reward {
        uint256 can;
        uint256 numCount;    
    }
    uint256 public withdrawFee = 5;
    address public feeAccount;
    mapping(address => uint256) public tokenToId;
    mapping(uint256 => CommunityToken) public communityTokens;
    uint256 public communityCount = 0;
    struct CommunityToken {
        uint256 id;
        string communityName;
        string symbol;
        address token;
        string logo;
        uint256 burn;
        uint256 lp;
    }
    address public wbbcAddress;
    address public usdtAddress;
    address private wBnbAddress;
    address private burnAddress;
    address private account; 
    IUniswapV2Router02 private v2Router;
    IUniswapV2Factory private v2Factory;
    TokenDistributor public immutable tokenDistributor;
    TokenDistributor public immutable wbbcPool; 
    event ShareEvent(address indexed user,address token,uint256 amount,uint256 powerNum,uint256 valueU,uint256 time);
    event BindEvent(address indexed newUser,address indexed oldUser,uint256 time);
    event InviteEvent(address indexed lower,address indexed parent,uint256 level,uint256 rewardPower,uint256 time);
    event WithdrawEvent(address indexed user,uint256 amount,uint256 time);
    event CommunityJoinEvent(uint256 indexed rank,address token,string symbol,string communityName,uint256 _burn,uint256 _lp,uint256 time);
    event TodayRewardSettleEvent(uint256 userCount,uint256 wbbcCount,uint256 time);

    constructor(address[] memory _adds) {
        level.push(10);
        level.push(5);
        feeAccount = _adds[0];
        wbbcAddress = _adds[2];
        usdtAddress = _adds[3];
        address _router = _adds[4];
        v2Router = IUniswapV2Router02(_router);
        v2Factory = IUniswapV2Factory(v2Router.factory());
        wBnbAddress = v2Router.WETH();
        burnAddress = _adds[5];
        account = _adds[6];
        IERC20(usdtAddress).approve(_router,~uint256(0));
        IERC20(wBnbAddress).approve(_router,~uint256(0));
        IERC20(wbbcAddress).approve(_router,~uint256(0));
        tokenDistributor = new TokenDistributor();
        wbbcPool = new TokenDistributor();
        initCommunity(_adds[1]);
    }

    function initCommunity(address _bbcAddr) internal {
        string memory _name = unicode"BBC";
        string memory _logo = unicode"https://www.loogooff.com/token_icon_request/667fd08efff76695dad53ae1_1719652494.png";
        addCommunity(_name, _logo,_bbcAddr, 50, 50);
        startTime = block.timestamp - (firstDayLong - 1 days);
        nextSettleBlock = block.number;
        allUser.push(_msgSender());
    }

    function setAllAddress(address[] memory _adds) public onlyOwner {
        feeAccount = _adds[0];
        wbbcAddress = _adds[1];
        usdtAddress = _adds[2];
        wBnbAddress = _adds[3];
        burnAddress = _adds[4];
        v2Router = IUniswapV2Router02(_adds[5]);
        v2Factory = IUniswapV2Factory(v2Router.factory());
        IERC20(wBnbAddress).approve(address(v2Router),~uint256(0));
        IERC20(usdtAddress).approve(address(v2Router),~uint256(0));
        IERC20(wbbcAddress).approve(address(v2Router),~uint256(0));
    }

    function addCommunity(string memory _communityName,string memory _logo,address _token,uint256 _burn,uint256 _lp) public onlyOwner {
        IERC20 _erc20 = IERC20(_token);
        string memory _symbol = _erc20.symbol();
        CommunityToken memory _community = CommunityToken({id:++communityCount,
                                                            communityName:_communityName,
                                                            symbol:_symbol,
                                                            logo: _logo,
                                                            token:_token,
                                                            burn:_burn,
                                                            lp:_lp});
        tokenToId[_token] = communityCount;
        communityTokens[communityCount] = _community;
        IERC20(_token).approve(address(v2Router),~uint256(0));
        emit CommunityJoinEvent(communityCount, _token, _symbol, _communityName,_burn,_lp, block.timestamp);
    }

    function updateCommunity(uint256 _id,string memory _communityName,string memory _logo,address _token,uint256 _burn,uint256 _lp) public onlyOwner {
        IERC20 _erc20 = IERC20(_token);
        string memory _symbol = _erc20.symbol();
        CommunityToken storage _community = communityTokens[_id]; 
        _community.communityName = _communityName;
        _community.symbol = _symbol;
        _community.logo = _logo;
        _community.token = _token;
        _community.burn = _burn;
        _community.lp = _lp;
        IERC20(_token).approve(address(v2Router),~uint256(0));
    }

    function putInto(uint256 _id,uint256 _amount,address _inviteUser) public {
        address _thisUser = _msgSender();
        require(!Address.isContract(_thisUser),"contract ban!");
        require(isOpenMine(),"open is not!");
        require(isBind(_inviteUser),"inviteUser is new!");
        require(_id > 0 && _id <= communityCount,"id not found!");
        require(_amount > 0,"amount is zero!");
        if(!isBind(_thisUser)){
            newBind(_thisUser, _inviteUser);
        }
        CommunityToken memory _community = communityTokens[_id];
        address _tokenAdd = _community.token;
        uint256 _burn = _community.burn;
        uint256 _lp = _community.lp;
        IERC20 _erc20 = IERC20(_tokenAdd);
        require(_erc20.balanceOf(_thisUser) >= _amount,"balance is not found!");
        require(_erc20.allowance(_thisUser,address(this)) >= _amount,"allowance is not found!");
        IERC20(_tokenAdd).transferFrom(_thisUser,address(this),_amount);
        (,uint256 _countU) = burnAndLP(_tokenAdd,_amount,_burn,_lp);
        uint256 _power = getPower(_countU);
        Share storage _share = shareInfos[_thisUser];
        _share.power += _power;
        _share.totalValue += _countU;
        countPower += _power;
        emit ShareEvent(_thisUser,_tokenAdd, _amount, _power,_countU, block.timestamp);
        parentPowerReward(_thisUser, _power);
        returnWBBCAndUSDT();
    }
    
    function returnWBBCAndUSDT() internal {
        uint256 _wbbcBalance = IERC20(wbbcAddress).balanceOf(address(this));
        if(_wbbcBalance > 0) IERC20(wbbcAddress).transfer(burnAddress,_wbbcBalance);
        uint256 _usdtBalance = IERC20(usdtAddress).balanceOf(address(this));
        if(_usdtBalance > 0) IERC20(usdtAddress).transfer(account,_usdtBalance);
    }

    function getPower(uint256 _valueU) public view returns(uint256) {
        uint256 _thisDayPower = thisDayPower();
        return calculate(_valueU, _thisDayPower);
    }

    function thisDayPower() public view returns(uint256) {
        if(block.timestamp < startTime) return initPower;
        uint256 _days = (block.timestamp - startTime) / 1 days;
        return initPower + _days * dayPower;
    }
    
    function burnAndLP(address _tokenAdd,uint256 _amount,uint256 _burn,uint256 _lp) internal returns(uint256 _valueU,uint256 _countU) {
        uint256 _burnAmount = calculate(_amount, _burn);
        IERC20(_tokenAdd).transfer(burnAddress,_burnAmount);
        uint256 _lpAmount = _amount.sub(_burnAmount);
        _valueU = sellToUsdt(_tokenAdd, _lpAmount);
        _countU = _valueU.mul(10**2).div(_lp);
        if(_countU < minShareU) revert();
        buyWBBCAndLP(_valueU);
    }
    
    function buyWBBCAndLP(uint256 _valueU) internal {
        uint256 _buyU = _valueU.div(2);
        address[] memory _path = new address[](2);
        _path[0] = usdtAddress;
        _path[1] = wbbcAddress;
        swapTokens(_path, _buyU, address(tokenDistributor));
        uint256 _outWBBCAmount = IERC20(_path[1]).balanceOf(address(tokenDistributor));
        tokenDistributor.claimToken(_path[1], _outWBBCAmount,address(this));
        uint256 _remainU = _valueU.sub(_buyU);
        addLiquidityUseUsdt(_path, _remainU, _outWBBCAmount);
    }

    function sellToUsdt(address _token,uint256 _amount) internal returns(uint256){
        (address[] memory _path,bool _isUsdtPair) = getPairUsdtOrBnb(_token);
        swapTokens(_path, _amount, address(tokenDistributor));
        uint256 _outAmount = IERC20(_path[1]).balanceOf(address(tokenDistributor));
        tokenDistributor.claimToken(_path[1], _outAmount,address(this));
        if(_isUsdtPair) {
            return _outAmount;
        }
        address[] memory _wbnbPath = new address[](2);
        _wbnbPath[0] = wBnbAddress;
        _wbnbPath[1] = usdtAddress;
        swapTokens(_wbnbPath, _outAmount, address(tokenDistributor));
        uint256 _outUsdtAmount = IERC20(_wbnbPath[1]).balanceOf(address(tokenDistributor));
        tokenDistributor.claimToken(_wbnbPath[1], _outUsdtAmount,address(this));
        return _outUsdtAmount;
    }

    function getPairUsdtOrBnb(address _token) internal view returns(address[] memory,bool) {
        address _usdtPair = v2Factory.getPair(_token, usdtAddress);
        address _wbnbPair = v2Factory.getPair(_token,wBnbAddress);
        if(_usdtPair == address(0) && _wbnbPair == address(0)) revert();
        address[] memory _path = new address[](2);
        _path[0] = _token;
        if(IERC20(_token).balanceOf(_usdtPair) >= IERC20(_token).balanceOf(_wbnbPair)){
            _path[1] = usdtAddress;
            return (_path,true);
        }
        _path[1] = wBnbAddress;
        return (_path,false);
    } 

    function swapTokens(address[] memory _path,uint256 _tokenAmount,address _to) internal { 
        v2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            _tokenAmount,
            0,
            _path,
            _to,
            block.timestamp
        );
    }

    function addLiquidityUseUsdt(address[] memory _path,uint256 _tokenAmount,uint256 _usdtAmount) internal {
        v2Router.addLiquidity(
            _path[0],
            _path[1],
            _tokenAmount,
            _usdtAmount,
            0,
            0,
            address(0),
            block.timestamp
        );
    }

    receive() external payable {
    }

    function isBind(address _user) public view returns(bool) {
        return bindAddress[_user] != address(0) || _user == owner();
    }

    function newBind(address _new,address _old) internal {
        bindAddress[_new] = _old;
        emit BindEvent(_new, _old, block.timestamp);
        Invite storage _level1 = inviteInfos[_old];
        _level1.num += 1;
        Invite storage _level2 = inviteInfos[bindAddress[_old]];
        _level2.num += 1;
        allUser.push(_new);
    }

    function parentPowerReward(address _user, uint256 _power) internal {
        address[] memory _parents = getParents(_user);
        for(uint256 i = 0;i < _parents.length;i++){
            if(_parents[i] != address(0)){
                uint256 _levelPower = calculate(_power, level[i]);
                Invite storage _invite = inviteInfos[_parents[i]];
                _invite.power += _levelPower;
                emit InviteEvent(_user, _parents[i], i + 1, _levelPower, block.timestamp);
                countPower += _levelPower;
            }
        }
    }

    function getParents(address _user) internal view returns(address[] memory){
        address[] memory _parents = new address[](2);
        _parents[0] = bindAddress[_user];
        _parents[1] = bindAddress[_parents[0]];
        return _parents;
    }
    
    function calculate(uint256 _amount,uint256 _fee) internal pure returns(uint256){
        return _amount.mul(_fee).div(10**2);
    }

    function getUserPower(address _user) public view returns(uint256) {
        Share memory _share = shareInfos[_user];
        Invite memory _invite = inviteInfos[_user];
        return _share.power + _invite.power;
    }
    
    function getTodayWBBC() public view returns(uint256) {
        if(!isOpen) {
            return firstNum * 30;
        }
        return block.timestamp < (startTime + firstDayLong) ? firstNum : usualNum; 
    } 

    function isOpenMine() public view returns(bool) {
        return block.timestamp >= startTime;
    }

    function getFirstMineCountDown() public view returns(uint256) {
        uint256 _firstMineDay = firstDayLong / 1 days;
        if(!isOpenMine()){
            return _firstMineDay;
        }
        return _firstMineDay - (block.timestamp - startTime) / 1 days;
    }

    function todayReward(address _user) public view returns(uint256) {
        uint256 _todayWBBC = getTodayWBBC();
        uint256 _userPower = getUserPower(_user);
        uint256 _limit = _userPower.mul(temp) / countPower;
        return(_limit * _todayWBBC) / temp;
    }

    function getUserReward(address _user) public view returns(uint256 _can,uint256 _wait,uint256 _count,uint256 _already) {
       Reward memory _reward = rewardInfos[_user];
       _can = _reward.can;
       _wait = todayReward(_user);
       _count = _can + _wait;
       _already = _reward.numCount;
    }
    
    function withdrawReward() public {
        address _user = _msgSender();
        Reward storage _reward = rewardInfos[_user];
        uint256 _can = _reward.can;
        require(_can > 0,"not reward!");
        uint256 _fee = calculate(_can, withdrawFee);
        wbbcPool.claimToken(wbbcAddress, _fee, feeAccount);
        wbbcPool.claimToken(wbbcAddress, _can.sub(_fee), _user);
        _reward.can = 0;
        _reward.numCount += _can;
        emit WithdrawEvent(_user, _can, block.timestamp); 
    }

    function settleAll() public onlyOwner {
        settleToday(0,allUser.length);
    }

    function settleToday(uint256 _start,uint256 _userCount) public onlyOwner {
        require(block.number >= nextSettleBlock ,"Settle loading...");
        uint256 _rewardCount;
        for(uint _i = _start;_i < _userCount;_i++){
            address _user = allUser[_i];
            uint256 _number = todayReward(_user);
            Reward storage _reward = rewardInfos[_user];
            _reward.can += _number;
            _rewardCount += _number;
        }
        nextSettleBlock += 86400 / 3;
        if(!isOpen) isOpen = true;
        emit TodayRewardSettleEvent(_userCount,_rewardCount,block.timestamp);
    }

    function getForecastSellUsdtAmount(uint256 _id,uint256 _amount) public view returns(uint256) {
        (address[] memory _path,bool _isUsdtPair) = getPairUsdtOrBnb(communityTokens[_id].token);
        uint256[] memory _outs = v2Router.getAmountsOut(_amount, _path);
        if(_isUsdtPair) {
            return _outs[1];
        }
        address[] memory _wbnbPath = new address[](2);
        _wbnbPath[0] = wBnbAddress;
        _wbnbPath[1] = usdtAddress;
        return v2Router.getAmountsOut(_outs[1], _wbnbPath)[1];
    }

    function setWbbcAddress(address _wbbcAddress) public onlyOwner {
        wbbcAddress = _wbbcAddress;
        IERC20(wbbcAddress).approve(address(v2Router),~uint256(0));
    }

    function setSettle(uint256 _num) public onlyOwner {
        nextSettleBlock = _num;
    }

}