pragma solidity 0.8.18;

interface IERC20 {
    function totalSupply() external view returns (uint256);

    function circulatingSupply() external view returns (uint256);

    function decimals() external view returns (uint8);

    function symbol() external view returns (string memory);

    function name() external view returns (string memory);

    function getOwner() external view returns (address);

    function balanceOf(address account) external view returns (uint256);

    function transfer(
        address recipient,
        uint256 amount
    ) external returns (bool);

    function allowance(
        address _owner,
        address spender
    ) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

abstract contract Ownable {
    address internal owner;

    constructor(address _owner) {
        owner = _owner;
    }

    modifier onlyOwner() {
        require(isOwner(msg.sender), "!OWNER");
        _;
    }

    function isOwner(address account) public view returns (bool) {
        return account == owner;
    }

    function transferOwnership(address payable newOwner) public onlyOwner {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );
        emit OwnershipTransferred(owner, newOwner); // Emit old and new owner
        owner = newOwner;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(owner, address(0));
        owner = address(0);
    }

    event OwnershipTransferred(address oldOwner, address newOwner);
}

interface IFactory {
    function createPair(
        address tokenA,
        address tokenB
    ) external returns (address pair);

    function getPool(
        address tokenA,
        address tokenB,
        uint24 fee
    ) external view returns (address pair);
}

interface IRouter {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);

    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    )
        external
        payable
        returns (uint amountToken, uint amountETH, uint liquidity);

    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint amountA, uint amountB);

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

contract KOMA is IERC20, Ownable {
    string private constant _name = "Koma Inu";
    string private constant _symbol = "KOMA";
    uint8 private constant _decimals = 18;
    uint256 private _totalSupply = 1_000_000_000 * (10 ** _decimals);
    mapping(address => uint256) _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => bool) public isFeeExempt;
    bool private tradingOpen = false;
    uint256 private initStartTime; // variable to track the start time of the initialization period
    IRouter router;
    address public pair;
    uint256 public buyFee = 500;
    uint256 public sellFee = 500;
    uint256 private initFee = 3000;
    uint256 private denominator = 10000;
    bool public swapAndLiqEnabled = true;
    bool private swapping;
    uint256 public TOKEN_SALE_THRESHOLD;
    address payable public marketing_receiver;

    uint256 private constant MAX_BUY_FEE = 500; // 5%
    uint256 private constant MAX_SELL_FEE = 500; // 5%

    uint256 private constant BUY_TAX_DURATION = 15 seconds; // Duration for buy tax
    uint256 private constant SELL_TAX_DURATION = 30 minutes; // Duration for sell tax
    uint256 private constant INITIAL_BUY_TAX = 3000; // 30%
    uint256 private constant INITIAL_SELL_TAX = 3000; // 30%

    modifier lockTheSwap() {
        swapping = true;
        _;
        swapping = false;
    }

    address internal constant DEAD = 0x000000000000000000000000000000000000dEaD;

    constructor() Ownable(msg.sender) {
        IRouter _router = IRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);
        address _pair = IFactory(0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73)
            .createPair(_router.WETH(), address(this));
        marketing_receiver = payable(
            0xd9F7ad3EF33B57b1305280FB1233e863056e3343);
        router = _router;
        pair = _pair;
        isFeeExempt[address(this)] = true;
        isFeeExempt[address(marketing_receiver)] = true;
        isFeeExempt[msg.sender] = true;
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
        TOKEN_SALE_THRESHOLD = 500_000 * (10 ** _decimals); // Initialize with default value
    }

    receive() external payable {}

    function name() public pure returns (string memory) {
        return _name;
    }

    function symbol() public pure returns (string memory) {
        return _symbol;
    }

    function decimals() public pure returns (uint8) {
        return _decimals;
    }

    function getOwner() external view override returns (address) {
        return owner;
    }

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(
        address recipient,
        uint256 amount
    ) public override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(
        address owner_,
        address spender
    ) public view override returns (uint256) {
        return _allowances[owner_][spender];
    }

    function setisExempt(address _address, bool _enabled) external onlyOwner {
        isFeeExempt[_address] = _enabled;
    }

    function approve(
        address spender,
        uint256 amount
    ) public override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function circulatingSupply() public view override returns (uint256) {
        return _totalSupply - balanceOf(DEAD) - balanceOf(address(0));
    }

    function preTxCheck(
        address sender,
        address recipient,
        uint256 amount
    ) internal view {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");
        require(
            amount > uint256(0),
            "Transfer amount must be greater than zero"
        );
        require(
            amount <= balanceOf(sender),
            "You are trying to transfer more than your balance"
        );
    }

    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) private {
        preTxCheck(sender, recipient, amount);
        checkTradingAllowed(sender, recipient);
        swapBack(sender, recipient, balanceOf(address(this)));
        _balances[sender] -= amount;
        uint256 amountReceived = shouldTakeFee(sender, recipient)
            ? takeFee(sender, recipient, amount)
            : amount;
        _balances[recipient] += amountReceived;
        emit Transfer(sender, recipient, amountReceived);
    }

    function setStructure(uint256 _buy, uint256 _sell) external onlyOwner {
        require(
            _buy <= MAX_BUY_FEE && _sell <= MAX_SELL_FEE,
            "Fees exceed maximum limits"
        );
        buyFee = _buy;
        sellFee = _sell;
        emit StructureUpdated(_buy, _sell);
    }

    function swapAndLiquify(uint256 tokens) private lockTheSwap {
        uint256 initialBalance = address(this).balance;
        swapTokensForETH(tokens);
        uint256 deltaBalance = address(this).balance - initialBalance;

        // Send all ETH directly to the marketing wallet
        if (deltaBalance > 0) {
            (bool success, ) = marketing_receiver.call{value: deltaBalance}("");
            if (!success) {
                emit TransferFailed(deltaBalance);
            }
        }
    }

    function swapTokensForETH(uint256 tokenAmount) private {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = router.WETH();
        _approve(address(this), address(router), tokenAmount);
        router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a > b ? a : b;
    }

    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    function shouldSwapBack(
        address sender,
        address recipient
    ) internal view returns (bool) {
        bool aboveThreshold = balanceOf(address(this)) >= TOKEN_SALE_THRESHOLD;
        return
            !swapping &&
            swapAndLiqEnabled &&
            !isFeeExempt[sender] &&
            recipient == pair &&
            aboveThreshold;
    }

    function swapBack(
        address sender,
        address recipient,
        uint256 amount
    ) internal {
        if (shouldSwapBack(sender, recipient)) {
            swapAndLiquify(amount); // Swap the entire balance
        }
    }

    function shouldTakeFee(
        address sender,
        address recipient
    ) internal view returns (bool) {
        bool isBuy = sender == pair;
        bool isSell = recipient == pair;
        return
            !isFeeExempt[sender] &&
            !isFeeExempt[recipient] &&
            (isBuy || isSell);
    }

    function getTotalFee(
        address sender,
        address recipient
    ) public view returns (uint256) {
        if (recipient == pair) {
            // Selling
            if (block.timestamp < initStartTime + SELL_TAX_DURATION) {
                uint256 timeElapsed = block.timestamp - initStartTime;
                uint256 sellTax = INITIAL_SELL_TAX -
                    ((INITIAL_SELL_TAX - sellFee) * timeElapsed) /
                    SELL_TAX_DURATION;
                return sellTax;
            }
            return sellFee; // After duration, return sellFee
        }
        if (sender == pair) {
            // Buying
            if (block.timestamp < initStartTime + BUY_TAX_DURATION) {
                uint256 timeElapsed = block.timestamp - initStartTime;
                uint256 buyTax = INITIAL_BUY_TAX -
                    ((INITIAL_BUY_TAX - buyFee) * timeElapsed) /
                    BUY_TAX_DURATION;
                return buyTax;
            }
            return buyFee; // After duration, return buyFee
        }
        return 0; // For transfers
    }

    function takeFee(
        address sender,
        address recipient,
        uint256 amount
    ) internal returns (uint256) {
        uint256 totalFee = getTotalFee(sender, recipient);
        if (totalFee > 0) {
            uint256 feeAmount = (amount * totalFee) / denominator; // Multiply first to maintain precision
            _balances[address(this)] += feeAmount;
            emit Transfer(sender, address(this), feeAmount);
            return amount - feeAmount;
        }
        return amount;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public override returns (bool) {
        uint256 currentAllowance = _allowances[sender][msg.sender];
        require(
            currentAllowance >= amount,
            "ERC20: transfer amount exceeds allowance"
        );
        _approve(sender, msg.sender, currentAllowance - amount);
        _transfer(sender, recipient, amount);
        return true;
    }

    function _approve(address owner_, address spender, uint256 amount) private {
        require(owner_ != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");
        _allowances[owner_][spender] = amount;
        emit Approval(owner_, spender, amount);
    }

    function startTrading() external onlyOwner {
        require(!tradingOpen, "Trading already enabled");
        tradingOpen = true;
        initStartTime = block.timestamp; // Set the start time to the current block timestamp
    }

    function checkTradingAllowed(
        address sender,
        address recipient
    ) internal view {
        if (!isFeeExempt[sender] && !isFeeExempt[recipient]) {
            require(tradingOpen, "ERC20: Trading is not allowed");
        }
    }

    function rescueETH() external onlyOwner {
        payable(msg.sender).transfer(address(this).balance);
    }

    function rescueERC20(address _address, uint256 _amount) external onlyOwner {
        require(_address != address(this), "Cannot rescue this token itself");
        IERC20(_address).transfer(msg.sender, _amount);
    }

    // Function to update the marketing receiver
    function setMarketingReceiver(address newReceiver) external onlyOwner {
        require(newReceiver != address(0), "Invalid address: zero address");
        marketing_receiver = payable(newReceiver);
        emit MarketingReceiverUpdated(newReceiver);
    }

    // Function to update the TOKEN_SALE_THRESHOLD
    function setTokenSaleThreshold(uint256 newThreshold) external onlyOwner {
        require(newThreshold > 0, "Threshold must be greater than zero");
        TOKEN_SALE_THRESHOLD = newThreshold;
        emit TokenSaleThresholdUpdated(newThreshold);
    }

    function setSwapAndLiqEnabled(bool _enabled) external onlyOwner {
        swapAndLiqEnabled = _enabled;
        emit SwapAndLiqEnabledUpdated(_enabled);
    }

    // Declare events
    event StructureUpdated(uint256 buyFee, uint256 sellFee);
    event MarketingReceiverUpdated(address newReceiver);
    event TokenSaleThresholdUpdated(uint256 newThreshold);
    event SwapAndLiqEnabledUpdated(bool enabled);
    event TransferFailed(uint256 amount);
}