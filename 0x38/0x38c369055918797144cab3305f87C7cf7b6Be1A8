{"ControlToken.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport \"./Ownable.sol\";\r\nimport \"./IERC20.sol\";\r\n\r\ninterface ISwapper {\r\n    function buy(address recipient, uint256 minOut) external payable;\r\n}\r\n\r\n/**\r\n    Modular Upgradeable-Tokenomics Immutable Token System\r\n */\r\ncontract ControlToken is IERC20, Ownable {\r\n\r\n    // total supply\r\n    uint256 private _totalSupply = 1_000_000_000 * 10**18;\r\n\r\n    // token data\r\n    string private constant _name = \u0027Control Token\u0027;\r\n    string private constant _symbol = \u0027CTRL\u0027;\r\n    uint8  private constant _decimals = 18;\r\n\r\n    // balances\r\n    mapping (address =\u003e uint256) private _balances;\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\r\n\r\n    // Taxation on transfers\r\n    uint256 public buyFee             = 1500;\r\n    uint256 public sellFee            = 2000;\r\n    uint256 public transferFee        = 0;\r\n    uint256 public constant TAX_DENOM = 10000;\r\n\r\n    // permissions\r\n    struct Permissions {\r\n        bool isFeeExempt;\r\n        bool isLiquidityPool;\r\n    }\r\n    mapping ( address =\u003e Permissions ) public permissions;\r\n\r\n    // Fee Recipients\r\n    address public sellFeeRecipient;\r\n    address public buyFeeRecipient;\r\n    address public transferFeeRecipient;\r\n\r\n    // Swapper Contract\r\n    address public swapper;\r\n    \r\n    constructor() {\r\n\r\n        // exempt sender for tax-free initial distribution\r\n        permissions[msg.sender].isFeeExempt = true;\r\n\r\n        // initial supply allocation\r\n        _balances[msg.sender] = _totalSupply;\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    /////////////////////////////////\r\n    /////    ERC20 FUNCTIONS    /////\r\n    /////////////////////////////////\r\n\r\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\r\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\r\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\r\n    \r\n    function name() public pure override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /** Transfer Function */\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transfer(msg.sender, recipient, amount);\r\n    }\r\n\r\n    /** Transfer Function */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        require(\r\n            _allowances[sender][msg.sender] \u003e= amount,\r\n            \u0027Insufficient Allowance\u0027\r\n        );\r\n        _allowances[sender][msg.sender] -= amount;\r\n        return _transfer(sender, recipient, amount);\r\n    }\r\n\r\n\r\n    /////////////////////////////////\r\n    /////   PUBLIC FUNCTIONS    /////\r\n    /////////////////////////////////\r\n\r\n\r\n    function burn(uint256 amount) external {\r\n        _burn(msg.sender, amount);\r\n    }\r\n\r\n    function burnFrom(address account, uint256 amount) external {\r\n        require(\r\n            _allowances[account][msg.sender] \u003e= amount,\r\n            \u0027Insufficient Allowance\u0027\r\n        );\r\n        _allowances[account][msg.sender] -= amount;\r\n        _burn(account, amount);\r\n    }\r\n\r\n    function buyFor(address recipient, uint256 minOut) external payable {\r\n        ISwapper(swapper).buy{value: msg.value}(recipient, minOut);\r\n    }\r\n\r\n    receive() external payable {\r\n        ISwapper(swapper).buy{value: msg.value}(msg.sender, 1);\r\n    }\r\n\r\n    /////////////////////////////////\r\n    /////    OWNER FUNCTIONS    /////\r\n    /////////////////////////////////\r\n\r\n    function setSwapper(address _swapper) external onlyOwner {\r\n        swapper = _swapper;\r\n    }\r\n\r\n    function withdrawTokens(address token) external onlyOwner {\r\n        require(token != address(0), \u0027Zero\u0027);\r\n        bool s = IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));\r\n        require(s);\r\n    }\r\n\r\n    function withdrawNative() external onlyOwner {\r\n        (bool s,) = payable(msg.sender).call{value: address(this).balance}(\"\");\r\n        require(s);\r\n    }\r\n\r\n    function setTransferFeeRecipient(address recipient) external onlyOwner {\r\n        require(recipient != address(0), \u0027Zero\u0027);\r\n        transferFeeRecipient = recipient;\r\n        permissions[recipient].isFeeExempt = true;\r\n    }\r\n\r\n    function setBuyFeeRecipient(address recipient) external onlyOwner {\r\n        require(recipient != address(0), \u0027Zero\u0027);\r\n        buyFeeRecipient = recipient;\r\n        permissions[recipient].isFeeExempt = true;\r\n    }\r\n\r\n    function setSellFeeRecipient(address recipient) external onlyOwner {\r\n        require(recipient != address(0), \u0027Zero\u0027);\r\n        sellFeeRecipient = recipient;\r\n        permissions[recipient].isFeeExempt = true;\r\n    }\r\n\r\n    function registerAutomatedMarketMaker(address account) external onlyOwner {\r\n        require(account != address(0), \u0027Zero Address\u0027);\r\n        require(!permissions[account].isLiquidityPool, \u0027AMM\u0027);\r\n        permissions[account].isLiquidityPool = true;\r\n    }\r\n\r\n    function unRegisterAutomatedMarketMaker(address account) external onlyOwner {\r\n        require(account != address(0), \u0027Zero Address\u0027);\r\n        require(permissions[account].isLiquidityPool, \u0027Not AMM\u0027);\r\n        permissions[account].isLiquidityPool = false;\r\n    }\r\n\r\n    function setFees(uint _buyFee, uint _sellFee, uint _transferFee) external onlyOwner {\r\n        require(\r\n            _buyFee \u003c= 2500,\r\n            \u0027Buy Fee Too High\u0027\r\n        );\r\n        require(\r\n            _sellFee \u003c= 2500,\r\n            \u0027Sell Fee Too High\u0027\r\n        );\r\n        require(\r\n            _transferFee \u003c= 2500,\r\n            \u0027Transfer Fee Too High\u0027\r\n        );\r\n\r\n        buyFee = _buyFee;\r\n        sellFee = _sellFee;\r\n        transferFee = _transferFee;\r\n    }\r\n\r\n    function setFeeExempt(address account, bool isExempt) external onlyOwner {\r\n        require(account != address(0), \u0027Zero Address\u0027);\r\n        permissions[account].isFeeExempt = isExempt;\r\n    }\r\n\r\n    \r\n    /////////////////////////////////\r\n    /////     READ FUNCTIONS    /////\r\n    /////////////////////////////////\r\n\r\n    function getTax(address sender, address recipient, uint256 amount) public view returns (uint256, address) {\r\n        if ( permissions[sender].isFeeExempt || permissions[recipient].isFeeExempt ) {\r\n            return (0, address(0));\r\n        }\r\n        return permissions[recipient].isLiquidityPool ? \r\n               ((amount * sellFee) / TAX_DENOM, sellFeeRecipient) :\r\n               permissions[sender].isLiquidityPool ? \r\n                ((amount * buyFee) / TAX_DENOM, buyFeeRecipient) : \r\n               ((amount * transferFee) / TAX_DENOM, transferFeeRecipient);\r\n    }\r\n\r\n    //////////////////////////////////\r\n    /////   INTERNAL FUNCTIONS   /////\r\n    //////////////////////////////////\r\n\r\n    /** Internal Transfer */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        require(\r\n            recipient != address(0),\r\n            \u0027Zero Recipient\u0027\r\n        );\r\n        require(\r\n            amount \u003e 0,\r\n            \u0027Zero Amount\u0027\r\n        );\r\n        require(\r\n            amount \u003c= balanceOf(sender),\r\n            \u0027Insufficient Balance\u0027\r\n        );\r\n        \r\n        // decrement sender balance\r\n        _balances[sender] -= amount;\r\n\r\n        // fee for transaction\r\n        (uint256 fee, address feeDestination) = getTax(sender, recipient, amount);\r\n\r\n        // give amount to recipient less fee\r\n        uint256 sendAmount = amount - fee;\r\n        require(sendAmount \u003e 0, \u0027Zero Amount\u0027);\r\n\r\n        // allocate balance\r\n        unchecked {\r\n            _balances[recipient] += sendAmount;\r\n        }\r\n        emit Transfer(sender, recipient, sendAmount);\r\n\r\n        // allocate fee if any\r\n        if (fee \u003e 0) {\r\n\r\n            // allocate amount to recipient\r\n            address feeRecipient = feeDestination != address(0) ? feeDestination : address(this);\r\n\r\n            // allocate fee\r\n            unchecked {\r\n                _balances[feeRecipient] += fee;\r\n            }\r\n            emit Transfer(sender, feeRecipient, fee);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal returns (bool) {\r\n        require(\r\n            account != address(0),\r\n            \u0027Zero Address\u0027\r\n        );\r\n        require(\r\n            amount \u003e 0,\r\n            \u0027Zero Amount\u0027\r\n        );\r\n        require(\r\n            amount \u003c= _balances[account],\r\n            \u0027Insufficient Balance\u0027\r\n        );\r\n\r\n        // delete from balance and supply\r\n        _balances[account] -= amount;\r\n        _totalSupply -= amount;\r\n\r\n        // emit transfer\r\n        emit Transfer(account, address(0), amount);\r\n        return true;\r\n    }\r\n}"},"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function symbol() external view returns(string memory);\r\n    \r\n    function name() external view returns(string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Returns the number of decimal places\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.20;\r\n\r\n/**\r\n * @title Owner\r\n * @dev Set \u0026 change owner\r\n */\r\ncontract Ownable {\r\n\r\n    address private owner;\r\n    \r\n    // event for EVM logging\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    // modifier to check if caller is owner\r\n    modifier onlyOwner() {\r\n        // If the first argument of \u0027require\u0027 evaluates to \u0027false\u0027, execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use \u0027require\u0027 to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() {\r\n        owner = msg.sender; // \u0027msg.sender\u0027 is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}"}}