// SPDX-License-Identifier: Unlicensed
pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

contract UltraStaking {
    using SafeMath for uint256;

    struct User {
        address referrer;
        uint256 referral_rewards;
        bool largest_qualified;
        uint256 deposit_time;
        uint256 claim_time;
        uint256 total_deposits;
        uint256 total_withdraws;
        uint256 total_withdraws_scaled;
        uint256 last_distPoints;
        uint256 lottery_winnings;
        uint256 largest_winnings;
        uint256 day_deposits;
    }

    address public glass;
    address private dev;
    
    mapping(uint256 => mapping(uint256 => address)) public lotteryContestants;
    mapping(uint256 => mapping(address => mapping(uint256 => mapping(uint256 => uint256)))) public lotteryTickets;
    mapping(address => User) public users;
    address[] public userIndices;

    uint256 public total_users;
    uint256 public total_deposited;
    uint256 public total_withdrawn;
    uint256 public total_rewards;
    uint256 public largestTime;
    uint256 public lastDripTime;
    uint256 public ticketPrice;
    uint256 public maxTickets;
    uint256 public minReferrer;
    uint256 public dripRate;
    uint256 public largestRewardBP;
    uint256 public randomRewardBP;
    uint256 public totalDistributeRewards;
    mapping(uint256 => address[]) public largestQualified;
    mapping(uint256 => address[]) public randomWinners;
    mapping(uint256 => uint256[]) public largestDeposits;
    mapping(uint256 => address[]) public largestTicketWinners;
    uint256 public totalDistributePoints;
    uint256 public rolloverDistributePoints;
    uint256 public unclaimedDistributeRewards;
    uint256 public compoundFeePercent;
    uint256 public depositFeePercent;
    uint256 public claimFeePercent;
    uint256 public lotteryId;
    uint256 public ticketId;
    uint256 public reductionWeigthPercent;
    uint256 public weekDay;
    uint256 public numRandomWinners;
    uint256 public winningsClaimFeePercent;
    uint256 public lotteryTime;
    uint256 public depositInstantRewardPercent;
    uint256 public rollInstantRewardPercent;
    uint256 public maxLargestWinners;
    uint256 public largestRewardTickets;
    uint256 public devFeePercent;
    uint256 public maxRandomWins;
    uint256 public minLargestBPx10;
    uint256 public dayTime; 
    uint256 public largestTimeIncrement;
    uint256 public lotteryTimeIncrement;
    uint256 public dayTimeIncrement;
    uint256 public minLargestRewardRatio;
    uint256 public compoundReferralFee;
    bool public depositEnabled;
    bool public claimEnabled;
    uint256 public constant MULTIPLIER = 10e18;
    uint256 public constant WEEKDAYS = 7;

    event NewDeposit(address indexed addr, address indexed ref, uint256 amount);
    event DirectPayout(
        address indexed addr,
        address indexed from,
        uint256 amount
    );
    event Withdraw(address indexed addr, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 tokens);

    constructor(address _glass, uint256 _largestTime, uint256 _lotteryTime, uint256 _dayTime) public {
        ticketPrice = SafeMath.mul(3e9, 1 gwei);
        maxTickets = 50;
        minReferrer = SafeMath.mul(27e8, 1 gwei); 
        largestTime = _largestTime;
        lotteryTime = _lotteryTime;
        dayTime = _dayTime;
        largestTimeIncrement = 8 hours;
        lotteryTimeIncrement = 7 days;
        dayTimeIncrement = 1 days;

        minLargestBPx10 = 25; // 0.025
        largestRewardBP = 5; // 0.05%
        randomRewardBP = 250; // 2.5%
        dripRate = 4214634; // 2.05% daily
        lastDripTime = block.timestamp;
        compoundFeePercent = 20;
        depositFeePercent = 10;
        claimFeePercent = 10;
        ticketId = 0;
        lotteryId = 0;
        reductionWeigthPercent = 40;
        numRandomWinners = 100;
        winningsClaimFeePercent = 33;
        depositInstantRewardPercent = 8;
        rollInstantRewardPercent = 0;
        maxLargestWinners = 500;
        maxRandomWins = 100;
        largestRewardTickets = 10;
        compoundReferralFee = 3;
        minLargestRewardRatio = 6;
        devFeePercent = 2;

        dev = msg.sender;
        glass = _glass;
        depositEnabled = true;
        claimEnabled = true;
    }

    receive() external payable {
        revert("Do not send BNB.");
    }

    modifier onlyDev() {
        require(msg.sender == dev, "Caller is not the dev!");
        _;
    }

    function changeDev(address payable newDev) external onlyDev {
        require(newDev != address(0), "Zero address");
        dev = newDev;
    }
    
    function migrateGlobals(
        uint256 _total_users,
        uint256 _total_deposited,
        uint256 _total_withdrawn,
        uint256 _total_rewards,
        uint256 _lastDripTime,
        uint256 _totalDistributeRewards,
        uint256 _totalDistributePoints,
        uint256 _rolloverDistributePoints,
        uint256 _unclaimedDistributeRewards
    ) external onlyDev {
        total_users = _total_users;
        total_deposited = _total_deposited;
        total_withdrawn = _total_withdrawn;
        total_rewards = _total_rewards;
        lastDripTime = _lastDripTime;
        totalDistributeRewards = _totalDistributeRewards;
        totalDistributePoints = _totalDistributePoints;
        rolloverDistributePoints = _rolloverDistributePoints;
        unclaimedDistributeRewards = _unclaimedDistributeRewards;
    }
    
    function migrateUsers(address[] memory _addrs, User[] memory _users) external onlyDev {        
        for (uint256 i = 0; i < _addrs.length; i++) { 
            address addr = _addrs[i];          
            if (users[addr].total_deposits == 0) {
                // if (_tickets[i] > 0) {
                //     _buyTickets(_addr[i], _tickets[i]);
                //     lotteryTickets[lotteryTime][_addr[i]][weekDay][1] = _tickets[i];
                // }
                // if (_user[i].deposit_time >= largestTime.sub(largestTimeIncrement) && _user[i].largest_qualified) {
                //     largestQualified[largestTime].push(_addr[i]);
                // }

                userIndices.push(addr);
                users[addr] = _users[i];
            }      
        }
    }

    function setUser(address _addr, User memory _user) external onlyDev {
        require(users[_addr].deposit_time > 0, "User does not exist");        
        users[_addr] = _user;
    }

    function setDepositEnabled(bool enabled) external onlyDev {
        depositEnabled = enabled;
    }
    
    function setClaimEnabled(bool enabled) external onlyDev {
        claimEnabled = enabled;
    }

    function setLargestTime(uint256 time) external onlyDev {
        largestTime = time;
    }

    function setLotteryTime(uint256 time) external onlyDev {
        lotteryTime = time;
    }
    
    function setDayTime(uint256 time) external onlyDev {
        dayTime = time;
    }

    function setLargestTimeIncrement(uint256 incrementSeconds) external onlyDev {
        largestTimeIncrement = incrementSeconds;
    }
    
    function setLotteryTimeIncrement(uint256 incrementSeconds) external onlyDev {
        lotteryTimeIncrement = incrementSeconds;
    }
    
    function setDayTimeIncrement(uint256 incrementSeconds) external onlyDev {
        dayTimeIncrement = incrementSeconds;
    }

    function setLargestRewardBP(uint256 bp) external onlyDev {
        largestRewardBP = bp;
    }
    
    function setRandomRewardBP(uint256 bp) external onlyDev {
        randomRewardBP = bp;
    }

    function setTicketPrice(uint256 amnt) external onlyDev {
        ticketPrice = amnt;
    }
    
    function setMaxTickets(uint256 amnt) external onlyDev {
        maxTickets = amnt;
    }
    
    function setMinReferrer(uint256 amnt) external onlyDev {
        minReferrer = amnt;
    }
    
    function setDripRate(uint256 rate) external onlyDev {
        dripRate = rate;
    }
    
    function setCompoundFeePercent(uint256 percent) external onlyDev {
        compoundFeePercent = percent;
    }
    
    function setDepositFeePercent(uint256 percent) external onlyDev {
        depositFeePercent = percent;
    }
    
    function setClaimFeePercent(uint256 percent) external onlyDev {
        claimFeePercent = percent;
    }
    
    function setReductionWeigthPercent(uint256 percent) external onlyDev {
        reductionWeigthPercent = percent;
    }
    
    function setWeekDay(uint256 day) external onlyDev {
        weekDay = day;
    }
    
    function setNumRandomWinners(uint256 numWinners) external onlyDev {
        numRandomWinners = numWinners;
    }
    
    function setMinLargest(uint256 bpx10) external onlyDev {
        minLargestBPx10 = bpx10;
    }

    function setwinningsClaimFeePercent(uint256 percent) external onlyDev {
        winningsClaimFeePercent = percent;
    }
    
    function setDepositInstantRewardPercent(uint256 percent) external onlyDev {
        depositInstantRewardPercent = percent;
    }
    
    function setRollInstantRewardPercent(uint256 percent) external onlyDev {
        rollInstantRewardPercent = percent;
    }
    
    function setMaxLargestWinners(uint256 max) external onlyDev {
        maxLargestWinners = max;
    }
    
    function setLargestRewardTickets(uint256 num) external onlyDev {
        largestRewardTickets = num;
    }
    
    function setDevFeePercent(uint256 percent) external onlyDev {
        devFeePercent = percent;
    }

    function setLargestQualified(address[] calldata qualifiedLst) external onlyDev {
        largestQualified[largestTime] = qualifiedLst;
    }
    
    function setMinLargestRewardRatio(uint256 min) external onlyDev {
        minLargestRewardRatio = min;
    }
    
    function setMaxRandomWins(uint256 max) external onlyDev {
        maxRandomWins = max;
    }
    
    function setCompoundReferralFee(uint256 amnt) external onlyDev {
        compoundReferralFee = amnt;
    }

    function emergencyWithdraw(uint256 amnt) external onlyDev {
        IBEP20(glass).transfer(dev, amnt);
    }

    function timeToReward() external view returns (uint256) {
        return block.timestamp < largestTime ? largestTime - block.timestamp : 0;
    }

    function random(uint256 _exlcusiveMax, uint256 _randInt) external view returns (uint256) {
        return _random(_exlcusiveMax, _randInt);
    }

    function listLargestQualified(uint256 time) external view returns (address[] memory) {
        return largestQualified[time];
    }
    
    function listLargestDeposits(uint256 time) external view returns (uint256[] memory) {
        if (time >= largestTime) {
            uint256[] memory amounts = new uint256[](largestQualified[largestTime].length);
            
            for (uint256 i = 0; i < largestQualified[largestTime].length; i++) {
                amounts[i] = users[largestQualified[largestTime][i]].day_deposits;
            }

            return amounts;
        }

        return largestDeposits[time];
    }
    
    function listLargestTicketWinners(uint256 time) external view returns (address[] memory) {
        return largestTicketWinners[time];
    }
    
    function listRandomWinners(uint256 time) external view returns (address[] memory) {
        return randomWinners[time];
    }

    function getLargestRatioRemaining() external view returns (uint256) {
        uint256 totalQualified = getLargestQualifiedTotal(largestTime).mul(depositFeePercent.add(100)).div(100);
        uint256 minTotal = _getGlassBalancePool().mul(largestRewardBP).div(10000).mul(minLargestRewardRatio);
        
        return totalQualified < minTotal ? minTotal.sub(totalQualified) : 0;
    }

    function getDayDeposits(address _addr) external view returns (uint256) {
        return users[_addr].deposit_time >= largestTime.sub(largestTimeIncrement) ? users[_addr].day_deposits : 0;
    }

    function _random(uint256 _exlcusiveMax, uint256 _randInt) internal view returns (uint256) {
        return
            uint256(
                keccak256(
                    abi.encodePacked(
                        block.timestamp,
                        block.difficulty,
                        _randInt
                    )
                )
            ) % _exlcusiveMax;
    }

    function trySendReward() external {
        return _trySendReward();
    }

    function _trySendReward() internal {
        uint256 timestamp = block.timestamp;
        if (timestamp >= dayTime) {
            weekDay++;
            dayTime = dayTime.add(dayTimeIncrement);
        }

        if (timestamp >= largestTime && timestamp < lotteryTime) {

            uint256 reward1 = _getGlassBalancePool().mul(largestRewardBP).div(10000);
            uint256 largestQualifiedTotal = getLargestQualifiedTotal(largestTime);
            bool isMinRatio = largestQualifiedTotal.mul(depositFeePercent.add(100)).div(100).div(reward1) >= minLargestRewardRatio;
            uint256 numQualified = largestQualified[largestTime].length;

            if (numQualified > 0 && isMinRatio) {
                
                address[] memory ticketRewardContestants = new address[](100);
                uint256 id = 0;
                
                for (uint256 i = 0; i < numQualified && i < maxLargestWinners; i++) {
                    address addr = largestQualified[largestTime][i];
                    uint256 dayDeposits = users[addr].day_deposits;
                    uint256 sharePercentage = dayDeposits.mul(100).div(largestQualifiedTotal);
                    
                    if (sharePercentage > 0) {
                        for (uint256 j = 0; j < sharePercentage; j++) {
                            ticketRewardContestants[id++] = addr;
                        }
                    }

                    uint256 shareAmount = reward1.mul(dayDeposits).div(largestQualifiedTotal);
                    users[addr].largest_winnings = users[addr].largest_winnings.add(shareAmount);
                    
                    largestDeposits[largestTime].push(dayDeposits);
                    total_rewards = total_rewards.add(shareAmount);
                }

                if (id > 0) {
                    uint256 randInt = _random(largestRewardTickets, id);

                    for (uint256 i = 0; i < largestRewardTickets; i++) {
                        address ticketWinner = ticketRewardContestants[_random(id, randInt**randInt)];
                        largestTicketWinners[largestTime].push(ticketWinner);

                        if (ticketWinner != address(0)) {
                            _buyTickets(ticketWinner, 1);
                            lotteryTickets[lotteryTime][ticketWinner][weekDay][0] = lotteryTickets[lotteryTime][ticketWinner][weekDay][0].add(1);
                        }

                        randInt++;
                    }
                }
            }

            uint256 prevLargestTime = largestTime;
            largestTime = largestTime.add(largestTimeIncrement);

            if (numQualified > 0 && !isMinRatio) {
                
                largestQualified[largestTime] = largestQualified[prevLargestTime];
                delete largestQualified[prevLargestTime];
                uint256 newDepositTime = prevLargestTime.add(1 seconds);

                for (uint256 i = 0; i < numQualified && i < maxLargestWinners; i++) {
                    
                    users[largestQualified[largestTime][i]].deposit_time = newDepositTime;
                }
            }
        }

        if (timestamp >= lotteryTime) {
            uint256 reward2 = _getGlassBalancePool().mul(randomRewardBP).div(10000).div(numRandomWinners);
            uint256 randInt = _random(numRandomWinners, ticketId);
            uint256 maxWinners = ticketId > numRandomWinners ? numRandomWinners : ticketId;
            
            for (uint256 i = 0; i < maxWinners; i++) {
                    
                address receiver2 = ticketId > 0 ? lotteryContestants[lotteryId][_random(ticketId, randInt**randInt)] : address(0);
                randInt++;

                if (receiver2 != address(0)) {
                        
                    if (maxRandomWins < numRandomWinners) {
                        uint256 numWins = 1;
                        
                        for (uint256 j = 0; j < i; j++) {
                            if (randomWinners[lotteryTime][j] == receiver2) {
                                numWins++;
                            }
                        }

                        if (numWins > maxRandomWins) {
                            i--;
                            continue;
                        }
                    }

                    users[receiver2].lottery_winnings = users[receiver2].lottery_winnings.add(reward2);
                    total_rewards = total_rewards.add(reward2);
                }
                    
                randomWinners[lotteryTime].push(receiver2);
            }

            rolloverDistributePoints = totalDistributePoints;
            total_rewards = total_rewards.sub(unclaimedDistributeRewards);
            unclaimedDistributeRewards = 0;
            lastDripTime = timestamp;

            ticketId = 0;
            lotteryId++;
            lotteryTime = lotteryTime.add(lotteryTimeIncrement);
            weekDay = 0;
        }
    }

    function _buyTickets(address to, uint256 numTix) internal {
        for (uint256 i = 0; i < numTix; i++) {
            lotteryContestants[lotteryId][ticketId++] = to;
        }
    }

    function _deposit(
        address _addr,
        uint256 _amount,
        address _referrer
    ) internal {
        require(depositEnabled, "Disabled.");
        if (_referrer != address(0)) {
            require(_referrer != _addr, "Cannot refer self.");
            require(
                users[_referrer].total_deposits > minReferrer,
                "Referrer has not depositted enough GLASS."
            );
        }
        require(_amount >= 1 gwei, "You must deposit a minimum of 1 GLASS.");
        require(
            IBEP20(glass).balanceOf(_addr) >= _amount,
            "Insufficient GLASS balance."
        );
        require(
            IBEP20(glass).allowance(_addr, address(this)) >= _amount,
            "Insufficient GLASS allowance."
        );

        /////////////////
        _trySendReward();
        /////////////////

        if (users[_addr].deposit_time > 0) {

            if (users[_addr].deposit_time < SafeMath.sub(largestTime, largestTimeIncrement)) {
                if (users[_addr].day_deposits != 0)
                    users[_addr].day_deposits = 0;
                if (users[_addr].largest_qualified)
                    users[_addr].largest_qualified = false;
            }
        } else {
            userIndices.push(_addr); // New user
            users[_addr].last_distPoints = totalDistributePoints;
            total_users++;
        }

        uint256 minLargest = _getGlassBalancePool().mul(minLargestBPx10).div(100000);
        uint256 balanceBefore = _getGlassBalance();
        IBEP20(glass).transferFrom(_addr, address(this), _amount);

        uint256 amountWithFee = _getGlassBalance().sub(balanceBefore);
        amountWithFee = amountWithFee.mul(SafeMath.sub(100, depositFeePercent)).div(100);

        users[_addr].referrer = _referrer;
        users[_addr].deposit_time = block.timestamp;
        users[_addr].total_deposits = users[_addr].total_deposits.add(amountWithFee);
        users[_addr].day_deposits = users[_addr].day_deposits.add(amountWithFee);

        total_deposited = total_deposited.add(amountWithFee);

        if (_referrer != address(0)) {
            users[_referrer].referral_rewards = users[_referrer].referral_rewards.add( // 3% (ref)
                amountWithFee.mul(3).div(100)
            );

            total_rewards = total_rewards.add(amountWithFee.mul(3).div(100));
        }

        IBEP20(glass).transfer(dev, amountWithFee.mul(devFeePercent).div(100)); // 2% (dev)
        _disperse(amountWithFee.mul(depositInstantRewardPercent).div(100)); // 8% (users)

        if (users[_addr].day_deposits >= minLargest.mul(SafeMath.sub(100, depositFeePercent)).div(100)) {
            
            if (!users[_addr].largest_qualified) {
                users[_addr].largest_qualified = true;
                largestQualified[largestTime].push(_addr);
            }
        }
        if (_amount >= ticketPrice) {

            uint256 numTix = (_amount.add(1)).div(ticketPrice);
            uint256 currentTix = lotteryTickets[lotteryTime][_addr][weekDay][0];

            if (currentTix < maxTickets) {
                if (numTix > maxTickets)
                    numTix = maxTickets;
                if (numTix.add(currentTix) > maxTickets)
                    numTix = maxTickets.sub(currentTix);

                _buyTickets(_addr, numTix);
                lotteryTickets[lotteryTime][_addr][weekDay][0] = currentTix.add(numTix);
            }
        }

        emit NewDeposit(_addr, _referrer, amountWithFee);
    }

    function deposit(uint256 amount) external {
        _deposit(msg.sender, amount, address(0));
    }

    function deposit(uint256 amount, address referrer) external {
        _deposit(msg.sender, amount, referrer);
    }

    function roll() public {
        _roll(msg.sender);
    }

    function _roll(address _sender) public {
        require(depositEnabled, "Disabled.");
        require(claimEnabled, "Disabled.");

        _dripRewards();

        uint256 _rewards = getRewards(_sender);
        require(_rewards > 0, "No rewards.");

        unclaimedDistributeRewards = unclaimedDistributeRewards.sub(getDistributionRewards(_sender));

        users[_sender].claim_time = block.timestamp;
        users[_sender].total_withdraws = users[_sender].total_withdraws.add(_rewards);
        users[_sender].total_withdraws_scaled = users[_sender].total_withdraws_scaled.add(_rewards.sub(users[_sender].largest_winnings).sub(users[_sender].lottery_winnings));
        total_withdrawn = total_withdrawn.add(_rewards);

        total_rewards = total_rewards.sub(_rewards);
        users[_sender].referral_rewards = 0;
        users[_sender].lottery_winnings = 0;
        users[_sender].largest_winnings = 0;

        users[_sender].last_distPoints = totalDistributePoints;

        emit Withdraw(_sender, _rewards);

        /////////////////
        _trySendReward();
        /////////////////
            
        if (users[_sender].deposit_time < SafeMath.sub(largestTime, largestTimeIncrement)) {
            if (users[_sender].day_deposits != 0)
                users[_sender].day_deposits = 0;
            if (users[_sender].largest_qualified)
                users[_sender].largest_qualified = false;
        }

        uint256 minLargest = _getGlassBalancePool().mul(minLargestBPx10).div(100000);
        uint256 rewardsPostClaim = _rewards.mul(SafeMath.sub(100, claimFeePercent)).div(100);
        _rewards = _rewards.mul(SafeMath.sub(100, compoundFeePercent)).div(100);

        users[_sender].deposit_time = block.timestamp;
        users[_sender].total_deposits = users[_sender].total_deposits.add(_rewards);
        users[_sender].day_deposits = users[_sender].day_deposits.add(_rewards);

        total_deposited = total_deposited.add(_rewards);

        address referrer = users[_sender].referrer;
        if (compoundReferralFee > 0 && referrer != address(0)) {
            users[referrer].referral_rewards = users[referrer].referral_rewards.add( // 3% (ref)
                _rewards.mul(compoundReferralFee).div(100)
            );

            total_rewards = total_rewards.add(_rewards.mul(3).div(100));
        }

        IBEP20(glass).transfer(dev, _rewards.mul(devFeePercent).div(100)); // 2% (dev)
        _disperse(_rewards.mul(rollInstantRewardPercent).div(100)); // 8% (users)

        if (users[_sender].day_deposits >= minLargest.mul(SafeMath.sub(100, depositFeePercent)).div(100)) {

            if (!users[_sender].largest_qualified) {
                users[_sender].largest_qualified = true;
                largestQualified[largestTime].push(_sender);
            }
        }
        if (rewardsPostClaim >= ticketPrice) {

            uint256 numTix = (rewardsPostClaim.add(1)).div(ticketPrice);
            uint256 currentTix = lotteryTickets[lotteryTime][_sender][weekDay][1];

            if (currentTix < maxTickets) {
                if (numTix > maxTickets)
                    numTix = maxTickets;
                if (numTix.add(currentTix) > maxTickets)
                    numTix = maxTickets.sub(currentTix);

                _buyTickets(_sender, numTix);
                lotteryTickets[lotteryTime][_sender][weekDay][1] = currentTix.add(numTix);
            }
        }

        emit NewDeposit(_sender, referrer, _rewards);
    }
    
    function _disperse(uint256 amount) internal {
        if (amount > 0 && total_deposited > 0) {
            totalDistributePoints = totalDistributePoints.add(amount.mul(MULTIPLIER).div(total_deposited));
            totalDistributeRewards = totalDistributeRewards.add(amount);
            total_rewards = total_rewards.add(amount);
            unclaimedDistributeRewards = unclaimedDistributeRewards.add(amount);
        }
    }

    function getDistributionRewards(address account) public view returns (uint256) {
        uint256 newDividendPoints;
        if (users[account].last_distPoints >= rolloverDistributePoints) { // last_DistPoints updated today
            newDividendPoints = totalDistributePoints.sub(users[account].last_distPoints);
        } else {
            newDividendPoints = totalDistributePoints.sub(rolloverDistributePoints);
        }

        uint256 factor = poolShareReductionFactor(account);
        
        if (factor > MULTIPLIER)
            factor = MULTIPLIER;

        uint256 distribute = users[account].total_deposits.mul(newDividendPoints).div(MULTIPLIER).mul(factor).div(MULTIPLIER);
        return distribute > unclaimedDistributeRewards ? unclaimedDistributeRewards : distribute;
    }

    function poolShareReductionFactor(address account) public view returns (uint256) {
        uint256 userWithdraws = users[account].total_withdraws_scaled.mul(SafeMath.sub(100, claimFeePercent)).div(100);
        uint256 userDeposits = users[account].total_deposits.mul(SafeMath.add(100, depositFeePercent)).div(100);
        
        if (userWithdraws >= userDeposits) {
            uint256 taperRatio = (userWithdraws.sub(userDeposits)).mul(MULTIPLIER).div(userDeposits).mul(8);
            
            if (taperRatio > MULTIPLIER.mul(975).div(1000))
                return MULTIPLIER.div(100);
            
            taperRatio = SafeMath.sub(MULTIPLIER, taperRatio);

            return taperRatio.mul(reductionWeigthPercent).div(100);
        }

        uint256 dcRatio = SafeMath.sub(MULTIPLIER, userWithdraws
            .mul(MULTIPLIER)
            .div(userDeposits));
        
        return ((((MULTIPLIER.sub(dcRatio)).mul(reductionWeigthPercent)).div(100)).add(dcRatio));
    }

    function getRewards(address _user) public view returns (uint256) {
        return users[_user].referral_rewards.add(users[_user].lottery_winnings).add(users[_user].largest_winnings).add(getDistributionRewards(_user));
    }
    
    function getTotalRewards(address _user) public view returns (uint256) {
        return
            users[_user].total_deposits > 0
                ? getRewards(_user).add(
                    _getRewardDrip()
                        .mul(users[_user].total_deposits)
                        .mul(poolShareReductionFactor(_user))
                        .div(total_deposited)
                        .div(MULTIPLIER)
                )
                : 0;
    }

    function claim() public {
        require(claimEnabled, "Disabled.");
        _dripRewards();

        address _sender = msg.sender;
        uint256 _rewards = getRewards(_sender);
        require(_rewards > 0, "No rewards.");

        unclaimedDistributeRewards = unclaimedDistributeRewards.sub(getDistributionRewards(_sender));

        uint256 payout = _rewards;
        uint256 lotteryWinnings = users[_sender].lottery_winnings;
        
        if (lotteryWinnings > 0) {
            payout = payout.sub(lotteryWinnings);
            lotteryWinnings = lotteryWinnings.mul(SafeMath.sub(100, winningsClaimFeePercent)).div(100);
            payout = payout.add(lotteryWinnings);
        }

        users[_sender].claim_time = block.timestamp;
        users[_sender].total_withdraws = users[_sender].total_withdraws.add(_rewards);
        users[_sender].total_withdraws_scaled = users[_sender].total_withdraws_scaled.add(payout.sub(users[_sender].largest_winnings).sub(lotteryWinnings));
        total_withdrawn = total_withdrawn.add(_rewards);

        IBEP20(glass).transfer(_sender, payout.mul(SafeMath.sub(100, claimFeePercent)).div(100));
        total_rewards = total_rewards.sub(_rewards);
        users[_sender].referral_rewards = 0;
        users[_sender].lottery_winnings = 0;
        users[_sender].largest_winnings = 0;

        users[_sender].last_distPoints = totalDistributePoints;

        _trySendReward();

        emit Withdraw(_sender, _rewards);
    }

    function dripRewards() external {
        _dripRewards();
    }

    function _dripRewards() internal {
        uint256 drip = _getRewardDrip();

        if (drip > 0) {
            _disperse(drip);
            lastDripTime = block.timestamp;
        }
    }

    function _getRewardDrip() internal view returns (uint256) {
        if (lastDripTime < block.timestamp) {
            uint256 poolBalance = _getGlassBalancePool();
            uint256 secondsPassed = block.timestamp.sub(lastDripTime);
            uint256 drip = secondsPassed.mul(poolBalance).div(dripRate);

            if (drip > poolBalance) {
                drip = poolBalance;
            }

            return drip;
        }
        return 0;
    }

    function getRewardDrip() external view returns (uint256) {
        return _getRewardDrip();
    }

    function getDayDripEstimate(address _user) external view returns (uint256) {
        return
            users[_user].total_deposits > 0
                ? _getGlassBalancePool()
                    .mul(86400)
                    .mul(users[_user].total_deposits)
                    .mul(poolShareReductionFactor(_user))
                    .div(total_deposited)
                    .div(dripRate)
                    .div(MULTIPLIER)
                : 0;
    }

    function numTicketsTotal(address _addr) external view returns (uint256) {
        uint256 totalTickets = 0;

        for (uint256 i = 0; i < WEEKDAYS; i++) {
            if (lotteryTickets[lotteryTime][_addr][i][0] != 0)
                totalTickets = totalTickets.add(lotteryTickets[lotteryTime][_addr][i][0]);
            if (lotteryTickets[lotteryTime][_addr][i][1] != 0)
                totalTickets = totalTickets.add(lotteryTickets[lotteryTime][_addr][i][1]);
        }

        return totalTickets;
    }
    
    function numTicketsDay(address _addr) external view returns (uint256) {
        return lotteryTickets[lotteryTime][_addr][weekDay][0].add(lotteryTickets[lotteryTime][_addr][weekDay][1]);
    }
    
    function numDepositTicketsRemaining(address _addr) external view returns (uint256) {
        return maxTickets.sub(lotteryTickets[lotteryTime][_addr][weekDay][0]);
    }
    
    function numRollTicketsRemaining(address _addr) external view returns (uint256) {
        return maxTickets.sub(lotteryTickets[lotteryTime][_addr][weekDay][1]);
    }

    function isLargestQualified(address _addr) external view returns (bool) {
        return users[_addr].deposit_time >= SafeMath.sub(largestTime, largestTimeIncrement) && users[_addr].largest_qualified;
    }

    function numLargestQualified(uint256 time) external view returns (uint256) {
        return largestQualified[time].length;
    }

    function getLargestQualifiedTotal(uint256 time) public view returns (uint256) {
        uint256 largestQualifiedTotal = 0;
        if (time == largestTime) {
            for (uint256 i = 0; i < largestQualified[time].length && i < maxLargestWinners; i++) {
                largestQualifiedTotal = largestQualifiedTotal.add(users[largestQualified[time][i]].day_deposits);
            }
        } else {
            for (uint256 i = 0; i < largestQualified[time].length && i < maxLargestWinners; i++) {
                largestQualifiedTotal = largestQualifiedTotal.add(largestDeposits[time][i]);
            }
        }
        return largestQualifiedTotal;
    }

    function getLargestDepositor() external view returns (address user, uint256 amount) {
        address _user = address(0);
        uint256 _amount = 0;
        for (uint256 i = 0; i < largestQualified[largestTime].length; i++) {
            
            address qualified = largestQualified[largestTime][i];
            
            if (users[qualified].deposit_time >= largestTime.sub(largestTimeIncrement) && users[qualified].day_deposits > _amount) {
                _amount = users[qualified].day_deposits;
                _user = qualified;
            }
        }

        return (_user, _amount);
    }

    function userInfo(address _addr)
        external
        view
        returns (
            uint256 deposit_time,
            uint256 referral_rewards,
            uint256 lottery_winnings,
            uint256 largest_winnings,
            address referrer
        )
    {
        return (
            users[_addr].deposit_time,
            users[_addr].referral_rewards,
            users[_addr].lottery_winnings,
            users[_addr].largest_winnings,
            users[_addr].referrer
        );
    }

    function userInfoTotals(address _addr)
        external
        view
        returns (
            uint256 total_withdraws,
            uint256 total_withdraws_scaled,
            uint256 total_deposits,
            uint256 last_distPoints,
            uint256 day_deposits
        )
    {
        return (
            users[_addr].total_withdraws,
            users[_addr].total_withdraws_scaled,
            users[_addr].total_deposits,
            users[_addr].last_distPoints,
            users[_addr].day_deposits
        );
    }

    function contractInfo()
        external
        view
        returns (
            uint256 _total_users,
            uint256 _total_deposited,
            uint256 _total_withdrawn,
            uint256 _total_rewards,
            uint256 _totalDistributeRewards
        )
    {
        return (total_users, total_deposited, total_withdrawn, total_rewards, totalDistributeRewards);
    }

    function getGlassBalancePool() external view returns (uint256) {
        return _getGlassBalancePool();
    }

    function _getGlassBalancePool() internal view returns (uint256) {
        return _getGlassBalance().sub(total_rewards);
    }

    function _getGlassBalance() internal view returns (uint256) {
        return IBEP20(glass).balanceOf(address(this));
    }

    function getGlassBalance() external view returns (uint256) {
        return _getGlassBalance();
    }
}

library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

interface IBEP20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}