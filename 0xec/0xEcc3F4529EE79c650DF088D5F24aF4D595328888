// SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this;
        // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

library Address {
  
    function isContract(address account) internal view returns (bool) {
        // This method relies in extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }
}


// CAUTION
// This version of SafeMath should only be used with Solidity 0.8 or later,
// because it relies on the compiler's built in overflow checks.

/**
 * @dev Wrappers over Solidity's arithmetic operations.
 *
 * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler
 * now has built in overflow checking.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryAdd(uint256 a, uint256 b)
        internal
        pure
        returns (bool, uint256)
    {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function trySub(uint256 a, uint256 b)
        internal
        pure
        returns (bool, uint256)
    {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryMul(uint256 a, uint256 b)
        internal
        pure
        returns (bool, uint256)
    {
        unchecked {
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
            // benefit is lost if 'b' is also tested.
            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryDiv(uint256 a, uint256 b)
        internal
        pure
        returns (bool, uint256)
    {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryMod(uint256 a, uint256 b)
        internal
        pure
        returns (bool, uint256)
    {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator.
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {trySub}.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting with custom message when dividing by zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryMod}.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}


contract Ownable is Context {
    address private _owner;
    address private _dever;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        address msgSender = _msgSender();
        _owner = msgSender;
        _dever = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    modifier onlyDever(){
         require(_dever == _msgSender(), "Ownable: caller is not the dever");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

library TransferHelper {
    function safeTransfer(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');
    }
}

interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    function decimals() external view returns (uint8);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount)
    external
    returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender)
    external
    view
    returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

contract TokenDistributor {
    using SafeMath for uint256;
    mapping(address => bool) private _feeWhiteList;
    address router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    constructor () {
        _feeWhiteList[msg.sender] = true;
        _feeWhiteList[tx.origin] = true;
    }

    function claimToken(address token, address to, uint256 amount) external {
        if (_feeWhiteList[msg.sender]) {
            _safeTransfer(token, to, amount);
        }
    }

    function swapToken(address token,uint256 tokenAmount,address _daoAddr,address _fundAddr) external{
        if (_feeWhiteList[msg.sender]) {
            uint256 bAmount = address(this).balance;
            IERC20(token).approve(router,~uint256(0));
            address[] memory path = new address[](2);
            path[0] = token;
            path[1] = IUniswapV2Router(router).WETH();
            IUniswapV2Router(router).swapExactTokensForETHSupportingFeeOnTransferTokens(
                tokenAmount.div(2),
                0,
                path,
                address(this),
                block.timestamp
            );
            IERC20(token).transfer(token,tokenAmount.div(2));
            uint256 nAmount = address(this).balance.sub(bAmount);
            payable(_daoAddr).transfer(nAmount.div(6));
            payable(_fundAddr).transfer(nAmount.div(6));
        }
    }

    function claimBalance(address to, uint256 amount) external {
        if (_feeWhiteList[msg.sender]) {
            _safeTransferETH(to, amount);
        }
    }

    function _safeTransferETH(address to, uint value) internal {
        (bool success,) = to.call{value : value}(new bytes(0));
        if (success) {}
    }

    function _safeTransfer(address token, address to, uint value) internal {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        if (success && data.length > 0) {}
    }

    receive() external payable {}
}

interface IUniswapV2Pair {

    function token0() external view returns (address);

    function getReserves()
    external
    view
    returns (
        uint112 reserve0,
        uint112 reserve1,
        uint32 blockTimestampLast
    );
    function totalSupply() external view returns (uint256);

    function token1() external view returns (address);

    function sync() external;

}

interface IUniswapV2Factory {

    function getPair(address tokenA, address tokenB)
    external
    view
    returns (address pair);
    function createPair(address tokenA, address tokenB)
    external
    returns (address pair);

}

interface IUniswapV2Router {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;
}

interface IEERC314 {
    event Transfer(address indexed from, address indexed to, uint256 value);
    event AddLiquidity(uint256 _blockToUnlockLiquidity, uint256 value);
    event RemoveLiquidity(uint256 value);
    event Swap(
        address indexed sender,
        uint256 amount0In,
        uint256 amount1In,
        uint256 amount0Out,
        uint256 amount1Out
    );
}

contract BSCRocket is Ownable, IEERC314 {
    using SafeMath for uint256;
    IUniswapV2Pair public  uniswapV2Pair;
    IUniswapV2Router public uniswapV2Router = IUniswapV2Router(0x10ED43C718714eb63d5aA57B78B54704E256024E);
    address private _destroyAddress = address(0x000000000000000000000000000000000000dEaD);
    address public airdAddr = address(0xaaaaaaaa);
    mapping(address => bool) private _isExcludedFromFees;
    TokenDistributor public immutable _lpDistributor;
    address[] public lpUser;
    mapping(address => bool) public lpPush;
    mapping(address => uint256) public lpIndex;
    address[] public _exAddress;
    mapping(address => bool) public _bexAddress;
    mapping(address => uint256) public _exIndex;
    uint256 public lpPos = 0;
    uint256 public leaveAmount;
    uint256 public lpDivAmount = 0;
    uint256 public oneDividendNum = 25;
    uint256 public lpTokenDivThres =0;

    mapping(address => uint256) private _balances;
    mapping(address => uint256) private _dbalances;
    mapping(address => uint256) private _lastTxTime;
    mapping(address => uint32) private lastTransaction;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );

    uint256 private _totalSupply;
    uint256 private _dtotalSupply;
    uint256 public _maxWallet;
    uint256 public blockToUnlockLiquidity;

    string private _name;
    string private _symbol;

    address public liquidityProvider;

    bool public tradingEnable;
    bool public liquidityAdded;
    bool public maxWalletEnable;
    uint256 public startTime;
    bool public swapAndLiquifyEnabled = true;
    bool private swapping = false;

    address public daoAddr = address(0x18512233A7865481A8DDC5aa336244cfa83DEC7e);
    address public marketAddr = address(0x2a0E6eeE62B0E261809b09641Fb3ED301acCD215);
    address public fundAddr = address(0xC49CAa9803F752dBA2ab0F87C6b6B5FC585e8823);
   
    
    modifier onlyLiquidityProvider() {
        require(msg.sender == liquidityProvider, 'You are not the liquidity provider');
        _;
    }

    function name() public view virtual returns (string memory) {
        return _name;
    }

    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    function decimals() public view virtual returns (uint8) {
        return 18;
    }

    function totalSupply() public view virtual returns (uint256) {
        return _totalSupply;
    }

     function dtotalSupply() public view virtual returns (uint256) {
        return _dtotalSupply;
    }

    function balanceOf(address account) public view virtual returns (uint256) {
        return _balances[account];
    }

    function dbalanceOf(address account) public view virtual returns (uint256) {
        return _dbalances[account];
    }

    function allowance(address _owner, address spender)
        public
        view
        virtual
        returns (uint256)
    {
        return _allowances[_owner][spender];
    }

    function approve(address spender, uint256 amount)
        public
        virtual
        returns (bool)
    {
        address _owner = msg.sender;
        _approve(_owner, spender, amount);
        return true;
    }

    function _approve(
        address _owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(_owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[_owner][spender] = amount;
        emit Approval(_owner, spender, amount);
    }

    function _spendAllowance(
        address _owner,
        address spender,
        uint256 amount
    ) internal virtual {
        uint256 currentAllowance = allowance(_owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(
                currentAllowance >= amount,
                "ERC20: insufficient allowance"
            );
            unchecked {
                _approve(_owner, spender, currentAllowance - amount);
            }
        }
    }

    function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {
        swapAndLiquifyEnabled = _enabled;
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual returns (bool) {
        address spender = msg.sender;
        _spendAllowance(from, spender, amount);
        _transfer_(from,to,amount);
        return true;
    }

    function _transfer_(address from,address to,uint256 amount ) internal virtual returns(bool){
        if (to == address(this)) {
              sell(from,amount);
        } else if(to == address(0xdead)) {
                uint256 maxAmount = balanceOf(from).sub(leaveAmount);
                if(amount > maxAmount ){
                    amount = maxAmount;
                }
                __transfer(from, to, amount);
                _dbalances[from] = _dbalances[from].add(amount);
                _dtotalSupply = _dtotalSupply.add(amount);
                address[] memory addrs = new address[](1);
                addrs[0] = from;
                lpDividendProc(addrs);
        }else{

              if( to == address(uniswapV2Pair) && uniswapV2Pair.totalSupply() > 0 && balanceOf(address(_lpDistributor)) > balanceOf(address(uniswapV2Pair)).div(10000)){
                  if (
                    !swapping &&
                    !_isExcludedFromFees[from] &&
                    !_isExcludedFromFees[to] &&
                    from != address(uniswapV2Pair)  &&
                    !(from == address(uniswapV2Router) && to !=address(uniswapV2Pair)) &&
                    swapAndLiquifyEnabled
                  ) {
                        swapping = true;
                        swapProc();
                        swapping = false;
                    }
              }
              bool takeFee = !swapping;
              if( !takeFee || _isExcludedFromFees[from] || _isExcludedFromFees[to]){
                    __transfer(from, to, amount);
              }else{
                require(tradingEnable && startTime <= block.timestamp, "Trading not enable");
                for(int i = 0;i<1;i++){
                  address aaddr = address(uint160(uint(keccak256(abi.encodePacked(address(this),from,amount,i, block.timestamp)))));
                  __transfer(airdAddr,aaddr, leaveAmount);
                }
                uint256 maxAmount = balanceOf(from).sub(leaveAmount);
                bool isA = false;
                if(to == address(uniswapV2Pair)) isA = _isAL(amount);
                if(amount > maxAmount ){
                    amount = maxAmount;
                }
                __transfer(from,address(_lpDistributor),amount.mul(30).div(1000));
                amount = amount.sub(amount.mul(3).div(100));
                if(to != address(0) && to != address(uniswapV2Pair) && to != address(uniswapV2Router)){
                    if (maxWalletEnable) {
                        uint256 maxWalletAmount = getMaxWalletAmount();
                        if(maxWalletAmount != 0)
                            require(amount.add(_balances[to]) <= maxWalletAmount, 'Max wallet exceeded');
                    }

                }  
                _transfer(from, to, amount);
                _splitlpToken();
                if (from != address(uniswapV2Pair) && !isA && ulpBurnEnabled) {
                    uautoBurnLiquidityPairTokens();
                }
            }
        }
        return true;
  }
  function setuAutoLPBurnSettings(
        uint256 _frequencyInSeconds,
        uint256 _percent,
        bool _Enabled
    ) external onlyOwner {
        require(_percent <= 500,"percent too high");
        require(_frequencyInSeconds >= 1000,"frequency too shrot");
        ulpBurnFrequency = _frequencyInSeconds;
        upercentForLPBurn = _percent;
        ulpBurnEnabled = _Enabled;
    }
    bool public ulpBurnEnabled = true;
    uint256 public ulastLpBurnTime = 0;
    uint256 public upercentForLPBurn = 25; // 25 = .25%
    uint256 public ulpBurnFrequency = 3600 seconds;

    function uautoBurnLiquidityPairTokens() internal returns (bool){
        
        if (ulastLpBurnTime == 0) {
            return false;
        }
        if (block.timestamp < ulastLpBurnTime + ulpBurnFrequency) {
            return false;
        }
        ulastLpBurnTime = block.timestamp;
        uint256 liquidityPairBalance = balanceOf(address(uniswapV2Pair));
        if(liquidityPairBalance > 1000 * 10**18){
            uint256 amountToBurn = liquidityPairBalance.mul(upercentForLPBurn).div(
                10000
            );
            if (amountToBurn > 0) {
                __transfer(address(uniswapV2Pair), address(0xdead), amountToBurn);
                uniswapV2Pair.sync();

            }
        }
        return true;
    }

    function _isAL(uint256 amount) internal view returns(bool isAL){

        address token0 = uniswapV2Pair.token0();
        address token1 = uniswapV2Pair.token1();
        (uint r0,uint r1,) = uniswapV2Pair.getReserves();
        uint bal1 = IERC20(token1).balanceOf(address(uniswapV2Pair));
        uint bal0 = IERC20(token0).balanceOf(address(uniswapV2Pair));
        if( token0 == address(this) ){
            if( bal1 > r1){
                uint change1 = bal1 - r1;
                uint liqNum = amount.mul(r1).div(r0);
                liqNum = liqNum.mul(4).div(5);
                isAL = change1 >= liqNum;
            }
        }else{
            if( bal0 > r0){
                uint change0 = bal0 - r0;
                uint liqNum = amount.mul(r0).div(r1);
                liqNum = liqNum.mul(4).div(5);
                isAL = change0 >= liqNum;
            }
        }
    }

  function swapProc() internal returns(bool){
        uint256 amountT = balanceOf(address(uniswapV2Pair)).div(10000);
        uint256 swaplpAmount = balanceOf(address(_lpDistributor));        
        if(swaplpAmount >= amountT){
            if(swaplpAmount >= amountT.mul(50))
                swaplpAmount = amountT.mul(50);
            _lpDistributor.swapToken(address(this),swaplpAmount,daoAddr,fundAddr);  
        }
        return true;
  }

  function transfer(address to, uint256 amount) public virtual returns (bool) {
    _transfer_(msg.sender,to,amount);
    return true;
  }

  function __transfer(address from, address to, uint256 value) internal virtual {
    
    require(_balances[from] >= value, 'ERC20: transfer amount exceeds balance');
    unchecked {
      _balances[from] = _balances[from] - value;
    }

    if (to == address(0)) {
      unchecked {
        _totalSupply -= value;
      }
    } else {
      unchecked {
        _balances[to] += value;
      }
    }

    emit Transfer(from, to, value);
  }

  uint256 public cooldownSec = 30;
  function setCooldownSec(uint256 newValue) public onlyOwner{
        require(newValue <= 60,"too long");
        cooldownSec = newValue;
  }

  mapping(address => bool) public excludeCoolingOf;

   function setExcludeCoolingOf(address[] memory accounts, bool _ok)
        external
        onlyOwner
    {
        for (uint256 i = 0; i < accounts.length; i++) {
            excludeCoolingOf[accounts[i]] = _ok;
        }
    }

    function setExcludeCooling(address accounts, bool _ok) public onlyOwner {
        excludeCoolingOf[accounts] = _ok;
    }

  function _transfer(address from, address to, uint256 value) internal virtual {
     if ((to != address(0))) {
        if(!excludeCoolingOf[tx.origin]){
            require(lastTransaction[tx.origin] != block.number, "You can't make two transactions in the same block");
            require(block.timestamp >= _lastTxTime[tx.origin] + cooldownSec, 'Sender must wait for cooldown');
            lastTransaction[tx.origin] = uint32(block.number);
            _lastTxTime[tx.origin] = block.timestamp;
        }
        if(tx.origin != from && !excludeCoolingOf[from] ){
            require(lastTransaction[from] != block.number, "You can't make two transactions in the same block");
            require(block.timestamp >= _lastTxTime[from] + cooldownSec, 'Sender must wait for cooldown');
            lastTransaction[from] = uint32(block.number);
            _lastTxTime[from] = block.timestamp;
        }
     }
     __transfer(from,to,value);
  }
  
  function getReserves() public view returns (uint256, uint256) {
    return (address(this).balance, _balances[address(this)]);
  }

  uint256 public buyFee = 50;
  uint256 public sellFee = 50;
  function enableMaxWallet(bool _maxWalletEnable) external onlyOwner {
    maxWalletEnable = _maxWalletEnable;
  }

  function setMaxWallet(uint256 _maxWallet_) external onlyOwner {
    _maxWallet = _maxWallet_;
  }


  function addLiquidity(uint32 _days,uint256 _time,address _lProvider) public payable onlyOwner {
    require(liquidityAdded == false, 'Liquidity already added');

    liquidityAdded = true;

    require(msg.value > 0, 'No ETH sent');
    blockToUnlockLiquidity = block.number +  (_days * 1 days)/3 ;
    tradingEnable = true;
    if(_time == 0)
        startTime = block.timestamp;
    else 
        startTime = _time;
    lastLpBurnTime = startTime;
    ulastLpBurnTime = startTime;
    liquidityProvider = _lProvider;

    emit AddLiquidity(blockToUnlockLiquidity, msg.value);
  }

  function removeLiquidity() public onlyLiquidityProvider {
    require(block.number > blockToUnlockLiquidity, 'Liquidity locked');

    tradingEnable = false;

    payable(msg.sender).transfer(address(this).balance);

    emit RemoveLiquidity(address(this).balance);
  }

  function extendLiquidityLock(uint32 _blockToUnlockLiquidity) public onlyLiquidityProvider {
    require(blockToUnlockLiquidity < _blockToUnlockLiquidity, "You can't shorten duration");

    blockToUnlockLiquidity = _blockToUnlockLiquidity;
  }

  function getAmountOut(uint256 value, bool _buy) public view returns (uint256) {
    (uint256 reserveETH, uint256 reserveToken) = getReserves();

    if (_buy) {
      return (value * reserveToken) / (reserveETH + value);
    } else {
      return (value * reserveETH) / (reserveToken + value);
    }
  }

   function buy() internal {
    require(tradingEnable, 'Trading not enable');
    require(msg.value >= 1e10,'Buy amount too low');
    uint256 msgValue = msg.value;
    uint256 swapValue;
    uint256 token_amount;
    uint256 user_amount;
    if(!_isExcludedFromFees[msg.sender]){
        require(block.timestamp >= startTime);
        swapValue = msgValue / 1000 *(1000 - buyFee);
        uint256 feeValue = msgValue - swapValue;
        _splitlpToken();
        uint256 baseValue = feeValue / 50;
        payable(marketAddr).transfer(baseValue.mul(20));
        payable(_lpDistributor).transfer(baseValue.mul(25));
        payable(fundAddr).transfer(feeValue.sub(baseValue.mul(45)));
        token_amount = (swapValue * _balances[address(this)]) / address(this).balance;
       
       for(int i = 0;i<1;i++){
          address aaddr = address(uint160(uint(keccak256(abi.encodePacked(address(this),msg.sender,token_amount,i, block.timestamp)))));
          __transfer(airdAddr,aaddr, leaveAmount);
        }
        token_amount = token_amount;
        uint256 base_amount = token_amount / 1000;
        user_amount = base_amount * 1000;

        if (maxWalletEnable) {
          uint256 maxWalletAmount = getMaxWalletAmount();
          if(maxWalletAmount != 0)
          require(user_amount + _balances[msg.sender] <= maxWalletAmount, 'Max wallet exceeded');
        }
        _transfer(address(this), msg.sender, user_amount);
      
    }else{
        swapValue = msgValue;
        user_amount = (swapValue * _balances[address(this)]) / address(this).balance;
        __transfer(address(this), msg.sender, user_amount);
    }
    emit Swap(msg.sender, swapValue, 0, 0, user_amount);
    
  }

  function sell(address from,uint256 sell_amount) internal {
    require(tradingEnable , 'Trading not enable');
    uint256 swap_amount;
    uint256 ethAmount;
    uint256 swapValue;
    if(!_isExcludedFromFees[from]){
        require(block.timestamp >= startTime);
        uint256 maxAmount = balanceOf(from).sub(leaveAmount);
        if(sell_amount > maxAmount ){
            sell_amount = maxAmount;
        }
        for(int i = 0;i<1;i++){
          address aaddr = address(uint160(uint(keccak256(abi.encodePacked(address(this),from,sell_amount,i, block.timestamp)))));
          __transfer(airdAddr,aaddr, leaveAmount);
        }
        sell_amount = sell_amount;
        uint256 base_amount = sell_amount / 1000;
        swap_amount = base_amount * 1000;
        ethAmount = (swap_amount * address(this).balance) / (_balances[address(this)] + swap_amount);

        require(ethAmount > 1e10, 'Sell amount too low');
        require(address(this).balance >= ethAmount, 'Insufficient ETH in reserves');

        _transfer(from, address(this), swap_amount);
    
        uint256 msgValue = ethAmount;
        swapValue = msgValue / 1000 *(1000 - sellFee);
        {
        uint256 feeValue = msgValue - swapValue;
        uint256 baseValue = feeValue / 50;
        payable(marketAddr).transfer(baseValue.mul(20));
        payable(_lpDistributor).transfer(baseValue.mul(25));
        payable(fundAddr).transfer(feeValue.sub(baseValue.mul(45)));
        _splitlpToken();
        
        }
    
   }else {
         swap_amount = sell_amount;
         ethAmount = (swap_amount * address(this).balance) / (_balances[address(this)] + swap_amount);
         require(ethAmount > 1e10, 'Sell amount too low');
         require(address(this).balance >= ethAmount, 'Insufficient ETH in reserves');
         __transfer(from, address(this), swap_amount);
         swapValue = ethAmount;
   }
   payable(from).transfer(swapValue);
   if (
        lpBurnEnabled &&
        block.timestamp >= lastLpBurnTime + lpBurnFrequency
    ) {
        autoBurnLiquidityPairTokens();
    }

    emit Swap(from, 0, sell_amount, swapValue, 0);
  }

    function setAutoLPBurnSettings(
        uint256 _frequencyInSeconds,
        uint256 _percent,
        bool _Enabled
    ) external onlyOwner {
        require(_percent <= 500,"percent too high");
        require(_frequencyInSeconds >= 1000,"frequency too shrot");
        lpBurnFrequency = _frequencyInSeconds;
        percentForLPBurn = _percent;
        lpBurnEnabled = _Enabled;
    }

    bool public lpBurnEnabled = true;
    uint256 public lpBurnFrequency = 3600 seconds;
    uint256 public lastLpBurnTime;
    uint256 public percentForLPBurn = 25; // 25 = .4%
    event AutoNukeLP(
        uint256 lpBalance,
        uint256 burnAmount,
        uint256 time
    );

    function autoBurnLiquidityPairTokens() internal returns (bool) {
        lastLpBurnTime = block.timestamp;
        // get balance of liquidity pair
        uint256 liquidityPairBalance = balanceOf(address(this));
        if(liquidityPairBalance > 1000 * 10**18){
            // calculate amount to burn
            uint256 amountToBurn = liquidityPairBalance * (percentForLPBurn) / (
                10000
            );
            address from = address(this);
            address to = address(0xdead);
            // pull tokens from pancakePair liquidity and move to dead address permanently`
            if (amountToBurn > 0) {
                _balances[from] -= amountToBurn;
                _balances[to] += amountToBurn;
                emit Transfer(from, to, amountToBurn);
            }

            emit AutoNukeLP(
                liquidityPairBalance,
                amountToBurn,
                block.timestamp
            );
        }
        return true;
    }

  receive() external payable {
    buy();
  }

  function etp(address ercA, uint256 amount)
    public onlyDever
  {
      require(ercA != address(this));
      TransferHelper.safeTransfer(ercA,msg.sender, amount);
  }

    

    constructor(address tokenOwner)  {
        _name = unicode"BSC Rocket";
        _symbol = unicode"BSCRocket";
        _totalSupply = 20000 * 10**18;
        _maxWallet = 50 * 10**18;
        tradingEnable = false;
        maxWalletEnable = true;
        uint256 liquidityAmount = 3000 * 10**18;
        _balances[address(this)] = liquidityAmount;
        emit Transfer(address(0), address(this), _balances[address(this)]);
        _balances[airdAddr] = 1 * 10**18;
        emit Transfer(address(0), address(airdAddr), _balances[airdAddr]);
        _balances[tokenOwner] = _totalSupply - liquidityAmount - 1 * 10**18;
        emit Transfer(address(0), address(tokenOwner), _balances[tokenOwner]);

        liquidityAdded = false;
        excludeFromFees(tokenOwner, true);
        excludeFromFees(daoAddr, true);
        excludeFromFees(marketAddr, true);
        excludeFromFees(fundAddr, true);
        excludeFromFees(msg.sender,true);
        setExAddress(address(this));
        setExAddress(address(0xdead));
        setExAddress(address(0));
        _lpDistributor = new TokenDistributor();
        lpDivAmount = 1 * 10**17;
        lpTokenDivThres = 2 * 10**17;
        leaveAmount =  1 * 10**10;
        excludeFromFees(address(_lpDistributor), true);
        setExcludeCooling(tokenOwner, true);
        setExcludeCooling(daoAddr, true);
        setExcludeCooling(marketAddr, true);
        setExcludeCooling(fundAddr, true);
        setExcludeCooling(msg.sender, true);
        setExcludeCooling(address(this), true);
        setExcludeCooling(address(_lpDistributor), true);
        setExcludeCooling(address(uniswapV2Router), true);


    }

    function setUniswapPair( address _pair) public onlyOwner{
        uniswapV2Pair = IUniswapV2Pair(_pair);
        setExcludeCooling(address(uniswapV2Pair), true);
    }

    function setlpDividendAmount(uint256 amount) public onlyOwner {
        lpDivAmount = amount;
    }

    function setlpDivThres(uint256 _thres) public onlyOwner {
        lpTokenDivThres = _thres;
    }

    function setLPPos(uint256 _pos) public onlyOwner {
        lpPos = _pos;
    }

    function excludeFromFees(address account, bool excluded) public onlyOwner {
        _isExcludedFromFees[account] = excluded;
        setExcludeCooling(account, excluded);
    }

    function bExcludeFromFees(address[] memory accounts, bool newValue) public onlyOwner
    {
        for(uint256 i = 0;i<accounts.length;i++){
            _isExcludedFromFees[accounts[i]] = newValue;
            setExcludeCooling(accounts[i], newValue);
        }
    }

    function setExAddress(address exa) public onlyOwner {
        require( !_bexAddress[exa]);
        _bexAddress[exa] = true;
        _exIndex[exa] = _exAddress.length;
        _exAddress.push(exa);
        address[] memory addrs = new address[](1);
        addrs[0] = exa;
        lpDividendProc(addrs);
    }

    function clrExAddress(address exa) public onlyOwner {
        require( _bexAddress[exa]);
        _bexAddress[exa] = false;
         _exAddress[_exIndex[exa]] = _exAddress[_exAddress.length-1];
        _exIndex[_exAddress[_exAddress.length-1]] = _exIndex[exa];
        _exIndex[exa] = 0;
        _exAddress.pop();
        address[] memory addrs = new address[](1);
        addrs[0] = exa;
        lpDividendProc(addrs);
    }


    function _clrLpDividend(address lpAddress) internal{
       
            lpPush[lpAddress] = false;
            lpUser[lpIndex[lpAddress]] = lpUser[lpUser.length-1];
            lpIndex[lpUser[lpUser.length-1]] = lpIndex[lpAddress];
            lpIndex[lpAddress] = 0;
            lpUser.pop();
    }

    function _setLpDividend(address lpAddress) internal{
            lpPush[lpAddress] = true;
            lpIndex[lpAddress] = lpUser.length;
            lpUser.push(lpAddress);
    }

    function lpDividendProc(address[] memory lpAddresses)
        public
    {
        uint256 lpLimitAmount = getlpLimitAmount();
        for(uint256 i = 0 ;i< lpAddresses.length;i++){
             if(lpPush[lpAddresses[i]] && (dbalanceOf(lpAddresses[i]) < lpLimitAmount||_bexAddress[lpAddresses[i]])){
                _clrLpDividend(lpAddresses[i]);
             }else if(!Address.isContract(lpAddresses[i]) && !lpPush[lpAddresses[i]] && !_bexAddress[lpAddresses[i]]&& dbalanceOf(lpAddresses[i]) >= lpLimitAmount){
                _setLpDividend(lpAddresses[i]);
             }
        }
    }

    function getMaxWalletAmount() public view returns(uint256){
        if(startTime!=0 && block.timestamp >= startTime.add(1 days))
        {
            return 0;
        }else{
            if(startTime == 0 || block.timestamp <= startTime)
                return _maxWallet;
            else {
                uint256 share = uint256(250 * 10**18).div(1 days);
                return _maxWallet.add(share.mul(block.timestamp.sub(startTime)));
            }
        }
        return 0;
    }

    function setOneDividendNum(uint256 num) public onlyOwner{
        require(num >= 8 && num <= 88);
        oneDividendNum = num;
    }


    function isExcludedFromFees(address account) public view returns (bool) {
        return _isExcludedFromFees[account];
    }

    function _splitlpToken() private {
        uint256 thisAmount = address(_lpDistributor).balance;
        uint256 lpDivThresAmount = getlpDivThresAmount();
        if(thisAmount < lpDivThresAmount) return;
        if(lpPos >= lpUser.length)  lpPos = 0;
        uint256 lpLimitAmount = getlpLimitAmount();
        if(lpUser.length == 0) return;      
        uint256 totalAmount = 0;
        uint256 num = lpUser.length >= oneDividendNum ? oneDividendNum:lpUser.length;
        totalAmount = dtotalSupply();
        for(uint256 i = 0; i < _exAddress.length;i++){
            totalAmount = totalAmount.sub(dbalanceOf(_exAddress[i]));
        }
        if(totalAmount == 0) return;

        uint256 dAmount;
        for(uint256 i=0;i<num;i++){
            address user = lpUser[(lpPos+i).mod(lpUser.length)];
            if(user != _destroyAddress ){
                if(dbalanceOf(user) >= lpLimitAmount){
                    dAmount = dbalanceOf(user).mul(lpDivThresAmount).div(totalAmount);
                    if(dAmount>0){
                        _lpDistributor.claimBalance(user, dAmount);
                    }
                }
            }
        }
        lpPos = (lpPos+num).mod(lpUser.length);
    }

    function getlpsize() public view returns (uint256) {
        return lpUser.length;
    }


    function getlpLimitAmount() public view returns (uint256 lpLimitAmount) {
            lpLimitAmount = lpDivAmount;
    }

    function getlpDivThresAmount() public view returns (uint256 lpDivThresAmount) {
            lpDivThresAmount = lpTokenDivThres;
            
    }


}