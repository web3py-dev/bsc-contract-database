
// File: contracts/Token.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface IERC20 {
    function decimals() external view returns (uint8);

    function symbol() external view returns (string memory);

    function name() external view returns (string memory);

    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(
        address recipient,
        uint256 amount
    ) external returns (bool);

    function allowance(
        address owner,
        address spender
    ) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

interface ISwapRouter {
    function factory() external pure returns (address);

    function getAmountsOut(
        uint amountIn,
        address[] calldata path
    ) external view returns (uint[] memory amounts);

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
}

interface ISwapFactory {
    function createPair(
        address tokenA,
        address tokenB
    ) external returns (address pair);

    function feeTo() external view returns (address);
}

interface ISwapPair {
    function getReserves()
        external
        view
        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);

    function totalSupply() external view returns (uint);

    function kLast() external view returns (uint);

    function sync() external;
}

abstract contract Ownable {
    address internal _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    constructor() {
        address msgSender = msg.sender;
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == msg.sender, "!o");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "n0");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

library Math {
    function min(uint x, uint y) internal pure returns (uint z) {
        z = x < y ? x : y;
    }

    function sqrt(uint y) internal pure returns (uint z) {
        if (y > 3) {
            z = y;
            uint x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }
}

contract TokenDistributor {
    mapping(address => bool) public isWhitelist;
    constructor() {
        isWhitelist[msg.sender] = true;
        isWhitelist[tx.origin] = true;
    }

    function claimToken(address token, address to, uint256 amount) external {
        if (isWhitelist[msg.sender]) {
            _safeTransfer(token, to, amount);
        }
    }

    function _safeTransfer(address token, address to, uint value) internal {
        (bool success, bytes memory data) = token.call(
            abi.encodeWithSelector(0xa9059cbb, to, value)
        );
        if (success && data.length > 0) {}
    }
}

contract Recv {
    IERC20 public token;
    IERC20 public usdt;

    constructor(IERC20 _token, IERC20 _usdt) {
        token = _token;
        usdt = _usdt;
    }

    function withdraw() public {
        uint256 usdtBalance = usdt.balanceOf(address(this));
        if (usdtBalance > 0) {
            usdt.transfer(address(token), usdtBalance);
        }
        uint256 tokenBalance = token.balanceOf(address(this));
        if (tokenBalance > 0) {
            token.transfer(address(token), tokenBalance);
        }
    }
}

interface IWBNB {
    function deposit() external payable;
    function withdraw(uint amount) external;
}

abstract contract AbsToken is IERC20, Ownable {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    address payable energyTankAddress;
    address payable constructionAddress;
    address payable luckyAddress;
    address payable holdTokenAddress;
    address payable liquidityAddress;
    address payable bcboperationAddress;
    address[] public authorized;
    address[] public whitelist ;
    mapping(address => bool) private isAuthorized;
    mapping(address => bool) public isWhitelist;
    uint256 public _maxWallet;
    bool public tradingEnable;
    bool public maxWalletEnable;
    Recv public recv;

    bool private inSwap;
    bool public _strictCheck = true;

    uint256 private _tTotal;

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    ISwapRouter private immutable _swapRouter;
    address private immutable _wbnb;
    mapping(address => bool) public _swapPairList;

    uint256 private constant MAX = ~uint256(0);

    address public immutable _mainPair;

    mapping(address => bool) public _swapRouters;

    TokenDistributor public immutable _buyDistributor;
    TokenDistributor public immutable _sellDistributor;

    modifier lockTheSwap() {
        inSwap = true;
        _;
        inSwap = false;
    }

    modifier onlyAuthorized() {
        require(isAuthorized[msg.sender] || msg.sender == owner(), "Not authorized");
        _;
    }

    constructor(
        address __routerAddress,
        address __wbnbAddress,
        string memory __name,
        string memory __symbol,
        uint8 __decimals,
        uint256 __supply,
        address __receiveAddress,
        address payable __energyTankAddress, 
        address payable __constructionAddress, 
        address payable __liquidityAddress,
        address payable __luckyAddress,
        address payable __holdTokenAddress,
        address payable __bcboperationAddress
    ) {
        _name = __name;
        _symbol = __symbol;
        _decimals = __decimals;
        _wbnb = __wbnbAddress;

        ISwapRouter swapRouter = ISwapRouter(__routerAddress);
        require(address(this) > _wbnb, "s");

        _swapRouter = swapRouter;
        _allowances[address(this)][address(swapRouter)] = MAX;
        _swapRouters[address(swapRouter)] = true;
        IERC20(_wbnb).approve(address(swapRouter), MAX);

        ISwapFactory swapFactory = ISwapFactory(swapRouter.factory());
        address pair = swapFactory.createPair(address(this), _wbnb);
        _swapPairList[pair] = true;
        _mainPair = pair;

        recv = new Recv(IERC20(this), IERC20(_wbnb));

        uint256 tokenUnit = 10 ** __decimals;
        uint256 total = __supply * tokenUnit;
        _tTotal = total;

        _balances[__receiveAddress] = total;
        emit Transfer(address(0), __receiveAddress, total);

        _maxWallet = total / 200;
        tradingEnable = false;
        maxWalletEnable = false;
 
        energyTankAddress = __energyTankAddress;
        constructionAddress = __constructionAddress;
        luckyAddress = __luckyAddress;
        holdTokenAddress = __holdTokenAddress;
        liquidityAddress = __liquidityAddress;
        bcboperationAddress = __bcboperationAddress;

        isWhitelist[__receiveAddress] = true;
        isWhitelist[address(this)] = true;
        isWhitelist[msg.sender] = true;
        isWhitelist[address(0)] = true;
        isWhitelist[address(0xdead)] = true;
        isWhitelist[address(recv)] = true;

        _buyDistributor = new TokenDistributor();
        _sellDistributor = new TokenDistributor();
    }

    function symbol() external view override returns (string memory) {
        return _symbol;
    }

    function name() external view override returns (string memory) {
        return _name;
    }

    function decimals() external view override returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view override returns (uint256) {
        return _tTotal;
    }

    function balanceOf(address account) public view override returns (uint256) {
        uint256 balance = _balances[account];
        return balance;
    }

    function transfer(
        address recipient,
        uint256 amount
    ) public override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(
        address owner,
        address spender
    ) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(
        address spender,
        uint256 amount
    ) public override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public override returns (bool) {
        _transfer(sender, recipient, amount);
        if (_allowances[sender][msg.sender] != MAX) {
            _allowances[sender][msg.sender] =
                _allowances[sender][msg.sender] -
                amount;
        }
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) private {
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _transfer(address from, address to, uint256 amount) private {
        uint256 balance = balanceOf(from);
        require(balance >= amount, "BNE");

        bool isAddLP;
        bool isRemoveLP;

        uint256 addLPLiquidity;
        if (to == _mainPair && msg.sender == address(_swapRouter)) {
            addLPLiquidity = _isAddLiquidity(amount);
            if (addLPLiquidity > 0) {
                isAddLP = true;
            }
        }

        uint256 removeLPLiquidity;
        if (from == _mainPair && to != address(_swapRouter)) {
            removeLPLiquidity = _isRemoveLiquidity(amount);
        } else if (from == address(_swapRouter)) {
            removeLPLiquidity = _isRemoveLiquidityETH(amount);
        }
        if (removeLPLiquidity > 0) {
            isRemoveLP = true;
        }

        bool takeFee;
        if (from == _mainPair || to == _mainPair) {
            if (!isWhitelist[from] && !isWhitelist[to]) {
                takeFee = true;
                if (isAddLP) {
                    takeFee = false;
                }
            }
        }

        if (isRemoveLP && !isWhitelist[to]) {
            takeFee = true;
        }

        _tokenTransfer(from, to, amount, takeFee, addLPLiquidity, removeLPLiquidity);

        if (maxWalletEnable && to != _mainPair && !isWhitelist[to]) {
            require(_maxWallet >= balanceOf(to), "Limit");
        }
    }

    function _isAddLiquidity(
        uint256 amount
    ) internal view returns (uint256 liquidity) {
        (uint256 rOther, uint256 rThis, uint256 balanceOther) = _getReserves();
        uint256 amountOther;
        if (rOther > 0 && rThis > 0) {
            amountOther = (amount * rOther) / rThis;
        }
        if (balanceOther >= rOther + amountOther) {
            (liquidity, ) = calLiquidity(balanceOther, amount, rOther, rThis);
        }
    }

    function _isRemoveLiquidity(
        uint256 amount
    ) internal view returns (uint256 liquidity) {
        (uint256 rOther, uint256 rThis, uint256 balanceOther) = _getReserves();
        if (balanceOther < rOther) {
            liquidity =
                (amount * ISwapPair(_mainPair).totalSupply()) /
                (balanceOf(_mainPair) - amount);
        } else if (_strictCheck) {
            uint256 amountOther;
            if (rOther > 0 && rThis > 0) {
                amountOther = (amount * rOther) / (rThis - amount);
                require(balanceOther >= amountOther + rOther);
            }
        }
    }

    function _isRemoveLiquidityETH(
        uint256 amount
    ) internal view returns (uint256 liquidity) {
        (uint256 rOther, , uint256 balanceOther) = _getReserves();
        //isRemoveLP
        if (balanceOther <= rOther) {
            liquidity =
                (amount * ISwapPair(_mainPair).totalSupply()) /
                balanceOf(_mainPair);
        }
    }

    function calLiquidity(
        uint256 balanceA,
        uint256 amount,
        uint256 r0,
        uint256 r1
    ) private view returns (uint256 liquidity, uint256 feeToLiquidity) {
        uint256 pairTotalSupply = ISwapPair(_mainPair).totalSupply();
        address feeTo = ISwapFactory(_swapRouter.factory()).feeTo();
        bool feeOn = feeTo != address(0);
        uint256 _kLast = ISwapPair(_mainPair).kLast();
        if (feeOn) {
            if (_kLast != 0) {
                uint256 rootK = Math.sqrt(r0 * r1);
                uint256 rootKLast = Math.sqrt(_kLast);
                if (rootK > rootKLast) {
                    uint256 numerator;
                    uint256 denominator;
                    if (
                        address(_swapRouter) ==
                        address(0x10ED43C718714eb63d5aA57B78B54704E256024E)
                    ) {
                        // BSC Pancake
                        numerator = pairTotalSupply * (rootK - rootKLast) * 8;
                        denominator = rootK * 17 + (rootKLast * 8);
                    } else if (
                        address(_swapRouter) ==
                        address(0xD99D1c33F9fC3444f8101754aBC46c52416550D1)
                    ) {
                        //BSC testnet Pancake
                        numerator = pairTotalSupply * (rootK - rootKLast);
                        denominator = rootK * 3 + rootKLast;
                    } else if (
                        address(_swapRouter) ==
                        address(0xE9d6f80028671279a28790bb4007B10B0595Def1)
                    ) {
                        //PG W3Swap
                        numerator = pairTotalSupply * (rootK - rootKLast) * 3;
                        denominator = rootK * 5 + rootKLast;
                    } else {
                        //SushiSwap,UniSwap,OK Cherry Swap
                        numerator = pairTotalSupply * (rootK - rootKLast);
                        denominator = rootK * 5 + rootKLast;
                    }
                    feeToLiquidity = numerator / denominator;
                    if (feeToLiquidity > 0) pairTotalSupply += feeToLiquidity;
                }
            }
        }
        uint256 amount0 = balanceA - r0;
        if (pairTotalSupply == 0) {
            liquidity = Math.sqrt(amount0 * amount) - 1000;
        } else {
            liquidity = Math.min(
                (amount0 * pairTotalSupply) / r0,
                (amount * pairTotalSupply) / r1
            );
        }
    }

    function _getReserves()
        private
        view
        returns (uint256 rOther, uint256 rThis, uint256 balanceOther)
    {
        (rOther, rThis) = __getReserves();
        balanceOther = IERC20(_wbnb).balanceOf(_mainPair);
    }

    function __getReserves()
        private
        view
        returns (uint256 rOther, uint256 rThis)
    {
        ISwapPair mainPair = ISwapPair(_mainPair);
        (uint r0, uint256 r1, ) = mainPair.getReserves();

        address tokenOther = _wbnb;
        if (tokenOther < address(this)) {
            rOther = r0;
            rThis = r1;
        } else {
            rOther = r1;
            rThis = r0;
        }
    }

    function _tokenTransfer(
        address sender,
        address recipient,
        uint256 tAmount,
        bool takeFee,
        uint256 addLPLiquidity,
        uint256 removeLPLiquidity
    ) private {
        _balances[sender] = _balances[sender] - tAmount;
        uint256 feeAmount;

        if (takeFee) {
            bool isSell;
            if (addLPLiquidity > 0) {
                //add liquidity
            } else if (removeLPLiquidity > 0) {
                //remove liquidity
            } else if (_swapPairList[sender]) {
                //buy
                require(tradingEnable, "no open buy trade");
                feeAmount = tAmount * 600 / 10000;
                _takeTransfer(sender, address(_buyDistributor), feeAmount);
            } else if (_swapPairList[recipient]) {
                //sell
                isSell = true;
                feeAmount = tAmount * 700 / 10000;
                _takeTransfer(sender, address(_sellDistributor), feeAmount);
            } else {
                //transfer
            }
            if (isSell && !inSwap) {
                swapTokenForFund();
            }
        }
        _takeTransfer(sender, recipient, tAmount - feeAmount);
    }

    function swapTokenForFund() private lockTheSwap {
        uint256 buyAmount = balanceOf(address(_buyDistributor));
        uint256 sellAmount = balanceOf(address(_sellDistributor));

        if (buyAmount > 0) {
            _buyDistributor.claimToken(address(this), address(this), buyAmount);
        }
        if (sellAmount > 0) {
            _sellDistributor.claimToken(address(this), address(this), sellAmount);
        }

        uint256 totalAmount = buyAmount + sellAmount;
        if (totalAmount == 0) return;

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = _wbnb;

        uint256 beforeBalance = address(this).balance;
        _swapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            totalAmount,
            0, // accept any amount of ETH
            path,
            address(this),
            block.timestamp
        );

        uint256 extraBalance = address(this).balance - beforeBalance;

        if (buyAmount > 0) {
            uint256 buyBalance = (extraBalance * buyAmount) / totalAmount;
            uint256 fee = buyBalance / 3;
            _safeTransferETH(energyTankAddress, fee);
            _safeTransferETH(holdTokenAddress, fee);
            _safeTransferETH(luckyAddress, fee);
        }
        if (sellAmount > 0) {
            uint256 sellBalance = (extraBalance * sellAmount) / totalAmount;
            _safeTransferETH(bcboperationAddress, sellBalance * 2 / 7);
            _safeTransferETH(energyTankAddress, sellBalance * 2 / 7);
            _safeTransferETH(constructionAddress, sellBalance * 3 / 7);
        }
    }
    
    function _takeTransfer(
        address sender,
        address to,
        uint256 tAmount
    ) private {
        _balances[to] = _balances[to] + tAmount;
        emit Transfer(sender, to, tAmount);
    }

    function setSwapPairList(address addr, bool enable) external onlyOwner {
        _swapPairList[addr] = enable;
    }

    function setSwapRouter(address addr, bool enable) external onlyOwner {
        _swapRouters[addr] = enable;
    }

    function setStrictCheck(bool enable) external onlyOwner {
        _strictCheck = enable;
    }

    receive() external payable {
        if(msg.sender != address(_swapRouter) && msg.sender == tx.origin){
            if (msg.value > 0) {
                uint256 swapEthAmount = msg.value * 10 / 100;
                uint256 feeAmount = swapEthAmount * 2 / 100;
                _safeTransferETH(energyTankAddress, feeAmount);
                _safeTransferETH(holdTokenAddress, feeAmount);
                _safeTransferETH(luckyAddress, feeAmount);
                uint256 balanceBefore = balanceOf(address(this));
                _swapEthForToken(swapEthAmount - (feeAmount * 3));
                uint256 swapedAmount = balanceOf(address(this)) - balanceBefore;
                _takeTransfer(address(this), msg.sender, swapedAmount);
                _swapAndAddLiquidity(msg.value * 40 / 100);
                _safeTransferETH(constructionAddress, msg.value * 5 / 100);
                _safeTransferETH(energyTankAddress, msg.value * 45 / 100);
            }
        }
    }

    function _swapAndAddLiquidity(uint256 stakeAmount) internal returns (bool) {
        uint256 stakingTokenAmount = stakeAmount / 2;
        uint256 balanceBefore = balanceOf(address(this));
        _swapEthForToken(stakingTokenAmount);
        uint256 swapedAmount = balanceOf(address(this)) - balanceBefore;
        _addLiquidity(stakingTokenAmount, swapedAmount);
        return true;
    }

    function _swapEthForToken(
        uint256 bnbBuyAmount
    ) internal returns (bool) {
        address[] memory path = new address[](2);
        path[0] = address(_wbnb);
        path[1] = address(this);
        _swapRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value:bnbBuyAmount}(
            0,
            path,
            address(recv),
            block.timestamp
        );
        recv.withdraw();
        return true;
    }

    function _addLiquidity(
        uint256 wbnbAmount,
        uint256 tokenAmount
    ) internal returns (bool) {
        IWBNB(address(_wbnb)).deposit{value: wbnbAmount}();
        _swapRouter.addLiquidity(
            address(_wbnb),
            address(this),
            wbnbAmount,
            tokenAmount,
            0,
            0,
            address(liquidityAddress),
            MAX
        );
        return true;
    }

    function _safeTransferETH(address to, uint value) internal {
        (bool success,) = to.call{value: value}(new bytes(0));
        if (success) {}
    }

    /**
     * @dev Returns the amount of ETH and tokens in the contract, used for trading.
     */
    function getReserves() public view returns (uint256, uint256) {
        return __getReserves();
    }

    /**
     * @dev Enables or disables trading.
     * @param _tradingEnable: true to enable trading, false to disable trading.
     * onlyOwner modifier
     */
    function enableTrading(bool _tradingEnable) external onlyAuthorized {
        tradingEnable = _tradingEnable;
    }

    /**
     * @dev Enables or disables the max wallet.
     * @param _maxWalletEnable: true to enable max wallet, false to disable max wallet.
     * onlyOwner modifier
     */
    function enableMaxWallet(bool _maxWalletEnable) external onlyAuthorized {
        maxWalletEnable = _maxWalletEnable;
    }

    /**
     * @dev Sets the max wallet.
     * @param _maxWallet_: the new max wallet.
     * onlyOwner modifier
     */
    function setMaxWallet(uint256 _maxWallet_) external onlyAuthorized {
        _maxWallet = _maxWallet_;
    }

    // 设置有权限的人，只能由合约创建者调用
    function setAuthorized(address _authorized) external onlyOwner {
        authorized.push(_authorized);
          isAuthorized[_authorized] = true;
    }

    //设置分红地址
    function setbonusAddress(
        address payable _energyTankAddress,
        address payable _constructionAddress,
        address payable _liquidityAddress,
        address payable _luckyAddress,
        address payable _holdTokenAddress,
        address payable _bcboperationAddress
    ) external onlyOwner {
        energyTankAddress = _energyTankAddress;
        constructionAddress = _constructionAddress;
        luckyAddress = _luckyAddress;
        holdTokenAddress = _holdTokenAddress;
        liquidityAddress = _liquidityAddress;
        bcboperationAddress = _bcboperationAddress;
    }

    /**
     * @dev Estimates the amount of tokens or ETH to receive when buying or selling.
     * @param value: the amount of ETH or tokens to swap.
     * @param _buy: true if buying, false if selling.
     */
    function getAmountOut(uint256 value, bool _buy)
        public
        view
        returns (uint256)
    {
        (uint256 reserveETH, uint256 reserveToken) = __getReserves();
        if (_buy) {
            return (value * reserveToken) / (reserveETH + value);
        } else {
            return (value * reserveETH) / (reserveToken + value);
        }
    }

    /**
     @dev add Whitelist
    */
   function addWhitelist(address[] calldata _addWhiteAddresses) external onlyOwner {
        for (uint256 i = 0; i < _addWhiteAddresses.length; i++) {
            address whiteAddress = _addWhiteAddresses[i];
            whitelist.push(whiteAddress);
            isWhitelist[whiteAddress] = true;
        }
    }

    /*
    *@select is bool whitelist
    */
    function getWhitelist(address _address)public view returns(bool) {
        return isWhitelist[_address];
    }

}

contract BCBcoin is AbsToken {
    constructor()
        AbsToken(
            address(0x10ED43C718714eb63d5aA57B78B54704E256024E),
            address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c),
            "BCBcoin",
            "BCBcoin",
            18,
            15_000_000,
            address(0x219d0fE6F366D65212e5dEbc70Ad1c518013Fa69),
            payable(0x9a7dBE92FEfbFB36651492BC7154adeeCb20c584),
            payable(0xD30e0B5FAf2109a561B70dCbf41F8e567Eb3c8eA),
            payable(0xbDa8D7B5bCcb09555554e9443e1Ee904F29FC403),
            payable(0x8b563eF8fb0aBBe728d877596681876DA4e39EFD),
            payable(0x34eD11B45253fE41f5DEE2295Ce187bFc757EF33),
            payable(0x56c83f2Ce78B6d49dad11bD1FddF53e080BCe110)
        )
    {}
}

