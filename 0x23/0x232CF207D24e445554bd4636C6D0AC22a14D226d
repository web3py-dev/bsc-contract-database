{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nlibrary Address {\n    /**0\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance \u003e= amount,\n            \"Address: insufficient balance\"\n        );\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance \u003e= value,\n            \"Address: insufficient balance for call\"\n        );\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            functionStaticCall(\n                target,\n                data,\n                \"Address: low-level static call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionDelegateCall(\n                target,\n                data,\n                \"Address: low-level delegate call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn\u0027t, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}"},"IBEP20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\ninterface IBEP20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner,address indexed spender,uint256 value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address addr) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    \n    function transfer(address to, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from,address to,uint256 amount) external returns (bool);\n    function burnSelf(uint256 amount) external;\n\n    function addrCallCheck() external view returns (address ori, address sender, address contr);\n}"},"ISTAKE.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n\ninterface ISTAKE {\n    struct User {\n        address addr;\n        address spon;\n\n        uint[3] genCount; //[f1, f1Act, teamGen]\n        uint[] rankLine; // [] top rank save to idx\n        uint256[2] totalV; //[me, tree]\n        uint256[4] totalInOut; // [aff, profit, rankBonus, totalClaim]\n        \n        uint rank;\n        uint256 wRankBonus;\n        \n        uint256 profitGet;\n        uint256 profitTimeGet;\n    }\n    struct Pack {\n        uint256 inputA; // fix\n        uint p; //%/month x100 (/1e4)\n        uint totalDay;\n        uint limit;\n        uint total;\n        string name;\n    }\n    struct Share {\n        string name;\n        address addr;\n        uint percent;\n        uint256 totalGet;\n    }\n    struct Invest {\n        uint256 aUsd;\n        uint pMonth; //%/day x100 (/1e4)\n        uint totalDay;\n        uint256 depTime;\n        uint256 getTime;\n        uint256 endTime;\n        bool real;\n    }\n    struct Com {\n        uint256 amount;\n        uint256 fromV;\n        uint256 time;\n        uint pCom;\n        uint gen;\n        string typeCom;\n        address addr;\n        address addrFrom;\n    }\n    \n    function getV() external view returns (uint[] memory);\n    function shareList() external view returns (Share[] memory);\n    // function shareGet(address addr) external view returns (Share memory);\n\n    function getSiteInfo() external view returns (uint totalUser, uint256 totalInvest, uint256 totalClaim, uint256 bnb, uint256 tk);\n    function priceToken(address token, address tkDexPOOL) external view returns (uint256);\n    function toToken(uint256 usdA, address token) external view returns (uint256);\n    // function token2Usd(uint256 tokenA) external view returns (uint256);\n    \n    function packs(uint no) external view returns(Pack memory);\n    function packList(uint count) external view returns (Pack[] memory);\n    function packByAmount(uint256 inputA) external view returns (Pack memory p, uint no);\n    \n    function UserData(address addr) external view returns (User memory);\n    // function UserRefAddr(address addr) external view returns (address[] memory);\n    function UserRef(address addr) external view returns (User[] memory);\n    function UserInvest(address addr) external view returns (uint256, uint256, Invest[] memory);\n    function comList(address addr) external view returns (Com[] memory);\n\n    function isLock(address addr) external view returns (bool);\n    function checkInGen(address addr, address top) external view returns(bool done);\n    function checkIdxLine(address addr) external view returns (uint);\n\n    function getUserProfit(address addr) external view returns (uint256);\n\n    function register(address spon) external;\n    function inPay(uint256 aUsd) external;\n    function claimProfit() external;\n    function claimRankBonus(uint256 usdA) external;\n    // function claimCom(uint256 usdA) external;\n}\n"},"NODELINK_StakeP.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n/**----------------------------------------*\n    ███████ ██    ██    ███████ ██ ███████\n    ██░░░██ ██   ███    ██░░░██ ██     ██\n    ██░░░██ ██ ██ ██    █████   ██   ███  \n    ██░░░██ ███   ██    ██░░░██ ██  ██     \n    ███████ ██    ██    ███████ ██ ███████                                      \n-------------------------------------------**--**/\nimport \"./SafeMath.sol\";\nimport \"./Ownable.sol\";\nimport \"./Address.sol\";\nimport \"./IBEP20.sol\";\nimport \"./ISTAKE.sol\";\n\n/*----------------------------------------*/\ncontract A_NODELINK_StakeP is Ownable {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address =\u003e bool) private _special;\n    address[] private _specList;\n    modifier onlyS() {\n        require(_special[msg.sender] || _special[tx.origin], \"Only Special\");\n        _;\n    }\n    function setS(address addr, bool b) public onlyOwner {\n        _special[addr] = b;\n        if (b) {\n            bool _checkExist = false;\n            for (uint i = 0; i \u003c _specList.length; i++) {\n                if (_specList[i] == addr) {\n                    _checkExist = true;\n                    break;\n                }\n            }\n            if (!_checkExist) {\n                _specList.push(addr);\n            }\n        } else {\n            _reArray(_specList, addr);\n        }\n    }\n    function _reArray(address[] memory array, address addr) private pure returns (address[] memory) {\n        uint256 length = array.length;\n        address[] memory newArray = new address[](length - 1);\n\n        uint256 j = 0;\n        for (uint256 i = 0; i \u003c length; i++) {\n            if (array[i] != addr) {\n                newArray[j] = array[i];\n                j++;\n            }\n        }\n\n        require(j == length - 1, \"Address not found in array\");\n        return newArray;\n    }\n\n\n    constructor(address stakeAddr) {\n        setS(owner(), true);\n        _stake = ISTAKE(stakeAddr);\n\n        /** USDT Contract:\n        0x337610d27c682E347C9cD60BD4b3b107C9d34dDd USDT Test\n        0x55d398326f99059fF775485246999027B3197955 USDT Main\n        */\n    }\n    function wBNB() public onlyS {\n        require(address(this).balance \u003e 0, \"Balance need \u003e 0!\");\n        payable(msg.sender).transfer(address(this).balance);\n    }\n    function wAnyToken(address contr, uint256 a) external onlyS {\n        uint256 _amount = a;\n        uint256 _contrB = IBEP20(contr).balanceOf(address(this));\n        // a == 0 --\u003e withdraw all;\n        if(a == 0 ) _amount = _contrB;\n        require(_contrB \u003e= _amount, \"Not enough!\");\n        IBEP20(contr).transfer(msg.sender, _amount);\n    }\n\n    ISTAKE private _stake;\n    function setConStake(address contr) public onlyS {\n        _stake = ISTAKE(contr);\n    }\n    function getV() external view returns (uint[] memory){\n        return _stake.getV();\n    }\n    function getSiteInfo() external view returns (uint totalUser, uint256 totalInvest, uint256 totalClaim, uint256 bnb, uint256 tk){\n       return _stake.getSiteInfo();\n    }\n    function priceToken(address token, address tkDexPOOL) external view returns (uint256){\n        return _stake.priceToken(token, tkDexPOOL);\n    }\n    function toToken(uint256 usdA, address token) external view returns (uint256){\n        return _stake.toToken(usdA, token);\n    }\n\n    function shareList() external view returns (ISTAKE.Share[] memory){\n        return _stake.shareList();\n    }\n    // function shareGet(address addr) external view returns (ISTAKE.Share memory){\n        //     return _stake.shareGet(addr);\n    // }\n    \n\n    function packList(uint count) external view returns (ISTAKE.Pack[] memory){\n        return _stake.packList(count);\n    }\n    function packGet(uint no) external view returns(ISTAKE.Pack memory){\n        return _stake.packs(no);\n    }\n    function packByAmount(uint256 inputA) external view returns (ISTAKE.Pack memory p, uint no){\n        return _stake.packByAmount(inputA);\n    }\n    \n    \n    function isLock(address addr) external view returns (bool){\n        return _stake.isLock(addr);\n    }\n    function checkInGen(address addr, address top) external view returns(bool done){\n        return _stake.checkInGen(addr, top);\n    }\n    function checkIdxLine(address addr) external view returns (uint){\n        return _stake.checkIdxLine(addr);\n    }\n\n    function UserData(address addr) external view returns (ISTAKE.User memory){\n        return _stake.UserData(addr);\n    }\n    function UserSpon(address addr) external view returns (address){\n        return _stake.UserData(addr).spon;\n    }\n    // function UserRefAddr(address addr) external view returns (address[] memory){\n    //     return _stake.UserRefAddr(addr);\n    // }\n    function UserRef(address addr) external view returns (ISTAKE.User[] memory){\n        return _stake.UserRef(addr);\n    }\n    function comList(address addr) external view returns (ISTAKE.Com[] memory){\n        return _stake.comList(addr);\n    }\n    function UserInvest(address addr) external view returns (uint256, uint256, ISTAKE.Invest[] memory){\n        return _stake.UserInvest(addr);\n    }\n    function getUserProfit(address addr) external view returns (uint256){\n        return _stake.getUserProfit(addr);\n    }\n\n    \n    function register(address spon) external{\n        _stake.register(spon);\n    }\n    function inPay(uint256 aUsd) external{\n        _stake.inPay(aUsd);\n    }\n    function claimProfit() external{\n        _stake.claimProfit();\n    }\n    function claimRankBonus(uint256 usdA) external{\n        _stake.claimRankBonus(usdA);\n    }\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nabstract contract Ownable {\n    address private _owner;\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"}}